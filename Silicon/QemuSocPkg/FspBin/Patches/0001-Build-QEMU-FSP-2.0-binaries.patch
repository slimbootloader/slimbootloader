From c8546b2fdc73eb435ce9db96917d845af56edf17 Mon Sep 17 00:00:00 2001
From: Aiden Park <aiden.park@intel.com>
Date: Wed, 11 Dec 2019 10:00:41 -0800
Subject: [PATCH] Build QEMU FSP 2.0 binaries

Signed-off-by: Aiden Park <aiden.park@intel.com>
Signed-off-by: Maurice Ma <maurice.ma@intel.com>
---
 BaseTools/Source/C/GNUmakefile                |   2 -
 BaseTools/Source/C/Makefile                   |   2 -
 BaseTools/Source/C/Makefiles/NmakeSubdirs.py  |   2 +-
 BuildFsp.py                                   | 394 +++++++++
 IntelFsp2Pkg/Tools/PatchFv.py                 |   7 +
 QemuFspPkg/BuildFv.cmd                        | 248 ++++++
 QemuFspPkg/FspDescription/FspDescription.inf  |  29 +
 QemuFspPkg/FspDescription/FspDescription.txt  |   2 +
 QemuFspPkg/FspHeader/FspHeader.aslc           |  90 ++
 QemuFspPkg/FspHeader/FspHeader.inf            |  49 ++
 QemuFspPkg/FspmInit/FspmInit.c                | 802 ++++++++++++++++++
 QemuFspPkg/FspmInit/FspmInit.h                |  77 ++
 QemuFspPkg/FspmInit/FspmInit.inf              |  67 ++
 QemuFspPkg/FspsInit/FspsInit.c                | 234 +++++
 QemuFspPkg/FspsInit/FspsInit.h                | 124 +++
 QemuFspPkg/FspsInit/FspsInit.inf              |  55 ++
 QemuFspPkg/Include/BootLoaderPlatformData.h   |  33 +
 QemuFspPkg/Include/ChipsetAccess.h            |  23 +
 QemuFspPkg/Include/FspUpd.h                   |  48 ++
 QemuFspPkg/Include/FspmUpd.h                  | 108 +++
 QemuFspPkg/Include/FspsUpd.h                  | 101 +++
 QemuFspPkg/Include/FsptUpd.h                  | 101 +++
 QemuFspPkg/Include/OvmfPlatforms.h            |  45 +
 QemuFspPkg/Include/Q35MchIch9.h               | 113 +++
 QemuFspPkg/Include/X58Ich10.h                 |  51 ++
 .../Library/PlatformSecLib/Ia32/Chipset.inc   | 121 +++
 .../Library/PlatformSecLib/Ia32/Ia32Nasm.inc  | 169 ++++
 .../PlatformSecLib/Ia32/PlatformNasm.inc      | 143 ++++
 .../PlatformSecLib/Ia32/SecCoreNasm.inc       |  61 ++
 .../Library/PlatformSecLib/Ia32/SecEntry.nasm | 730 ++++++++++++++++
 .../Library/PlatformSecLib/PlatformSecLib.c   |  85 ++
 .../Library/PlatformSecLib/PlatformSecLib.h   |  48 ++
 .../PlatformSecLib/Vtf0PlatformSecMLib.inf    |  61 ++
 .../PlatformSecLib/Vtf0PlatformSecSLib.inf    |  63 ++
 .../PlatformSecLib/Vtf0PlatformSecTLib.inf    |  67 ++
 QemuFspPkg/QemuFspPkg.dec                     |  51 ++
 QemuFspPkg/QemuFspPkg.dsc                     | 436 ++++++++++
 QemuFspPkg/QemuFspPkg.fdf                     | 278 ++++++
 QemuFspPkg/QemuVideo/QemuVideo.c              | 780 +++++++++++++++++
 QemuFspPkg/QemuVideo/QemuVideo.h              | 116 +++
 QemuFspPkg/QemuVideo/QemuVideo.inf            |  56 ++
 41 files changed, 6067 insertions(+), 5 deletions(-)
 create mode 100644 BuildFsp.py
 create mode 100644 QemuFspPkg/BuildFv.cmd
 create mode 100644 QemuFspPkg/FspDescription/FspDescription.inf
 create mode 100644 QemuFspPkg/FspDescription/FspDescription.txt
 create mode 100644 QemuFspPkg/FspHeader/FspHeader.aslc
 create mode 100644 QemuFspPkg/FspHeader/FspHeader.inf
 create mode 100644 QemuFspPkg/FspmInit/FspmInit.c
 create mode 100644 QemuFspPkg/FspmInit/FspmInit.h
 create mode 100644 QemuFspPkg/FspmInit/FspmInit.inf
 create mode 100644 QemuFspPkg/FspsInit/FspsInit.c
 create mode 100644 QemuFspPkg/FspsInit/FspsInit.h
 create mode 100644 QemuFspPkg/FspsInit/FspsInit.inf
 create mode 100644 QemuFspPkg/Include/BootLoaderPlatformData.h
 create mode 100644 QemuFspPkg/Include/ChipsetAccess.h
 create mode 100644 QemuFspPkg/Include/FspUpd.h
 create mode 100644 QemuFspPkg/Include/FspmUpd.h
 create mode 100644 QemuFspPkg/Include/FspsUpd.h
 create mode 100644 QemuFspPkg/Include/FsptUpd.h
 create mode 100644 QemuFspPkg/Include/OvmfPlatforms.h
 create mode 100644 QemuFspPkg/Include/Q35MchIch9.h
 create mode 100644 QemuFspPkg/Include/X58Ich10.h
 create mode 100644 QemuFspPkg/Library/PlatformSecLib/Ia32/Chipset.inc
 create mode 100644 QemuFspPkg/Library/PlatformSecLib/Ia32/Ia32Nasm.inc
 create mode 100644 QemuFspPkg/Library/PlatformSecLib/Ia32/PlatformNasm.inc
 create mode 100644 QemuFspPkg/Library/PlatformSecLib/Ia32/SecCoreNasm.inc
 create mode 100644 QemuFspPkg/Library/PlatformSecLib/Ia32/SecEntry.nasm
 create mode 100644 QemuFspPkg/Library/PlatformSecLib/PlatformSecLib.c
 create mode 100644 QemuFspPkg/Library/PlatformSecLib/PlatformSecLib.h
 create mode 100644 QemuFspPkg/Library/PlatformSecLib/Vtf0PlatformSecMLib.inf
 create mode 100644 QemuFspPkg/Library/PlatformSecLib/Vtf0PlatformSecSLib.inf
 create mode 100644 QemuFspPkg/Library/PlatformSecLib/Vtf0PlatformSecTLib.inf
 create mode 100644 QemuFspPkg/QemuFspPkg.dec
 create mode 100644 QemuFspPkg/QemuFspPkg.dsc
 create mode 100644 QemuFspPkg/QemuFspPkg.fdf
 create mode 100644 QemuFspPkg/QemuVideo/QemuVideo.c
 create mode 100644 QemuFspPkg/QemuVideo/QemuVideo.h
 create mode 100644 QemuFspPkg/QemuVideo/QemuVideo.inf

diff --git a/BaseTools/Source/C/GNUmakefile b/BaseTools/Source/C/GNUmakefile
index 464f432774..c20a227334 100644
--- a/BaseTools/Source/C/GNUmakefile
+++ b/BaseTools/Source/C/GNUmakefile
@@ -48,8 +48,6 @@ all: makerootdir subdirs
 LIBRARIES = Common
 VFRAUTOGEN = VfrCompile/VfrLexer.h
 APPLICATIONS = \
-  BrotliCompress \
-  VfrCompile \
   EfiRom \
   GenFfs \
   GenFv \
diff --git a/BaseTools/Source/C/Makefile b/BaseTools/Source/C/Makefile
index e8f8abe59a..008f3f5a20 100644
--- a/BaseTools/Source/C/Makefile
+++ b/BaseTools/Source/C/Makefile
@@ -10,8 +10,6 @@ HOST_ARCH = IA32
 
 LIBRARIES = Common
 APPLICATIONS = \
-  VfrCompile \
-  BrotliCompress \
   EfiRom \
   GenCrc32 \
   GenFfs \
diff --git a/BaseTools/Source/C/Makefiles/NmakeSubdirs.py b/BaseTools/Source/C/Makefiles/NmakeSubdirs.py
index 1f4a45004f..49a0ccee7b 100644
--- a/BaseTools/Source/C/Makefiles/NmakeSubdirs.py
+++ b/BaseTools/Source/C/Makefiles/NmakeSubdirs.py
@@ -33,7 +33,7 @@ def RunCommand(WorkDir=None, *Args, **kwargs):
     if "stderr" not in kwargs:
         kwargs["stderr"] = subprocess.STDOUT
     if "stdout" not in kwargs:
-        kwargs["stdout"] = subprocess.PIPE
+        kwargs["stdout"] = sys.stdout
     p = subprocess.Popen(Args, cwd=WorkDir, stderr=kwargs["stderr"], stdout=kwargs["stdout"])
     stdout, stderr = p.communicate()
     message = ""
diff --git a/BuildFsp.py b/BuildFsp.py
new file mode 100644
index 0000000000..c1475be22a
--- /dev/null
+++ b/BuildFsp.py
@@ -0,0 +1,394 @@
+#!/usr/bin/env python
+## @ BuildFsp.py
+# Build FSP main script
+#
+# Copyright (c) 2016 - 2018, Intel Corporation. All rights reserved.<BR>
+# This program and the accompanying materials are licensed and made available under
+# the terms and conditions of the BSD License that accompanies this distribution.
+# The full text of the license may be found at
+# http://opensource.org/licenses/bsd-license.php.
+#
+# THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+# WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+##
+
+##
+# Import Modules
+#
+import os
+import sys
+import re
+import errno
+import shutil
+import argparse
+import subprocess
+import multiprocessing
+from ctypes import *
+
+def get_file_data (file, mode = 'rb'):
+    return open(file, mode).read()
+
+def run_process (arg_list, print_cmd = False, capture_out = False):
+    sys.stdout.flush()
+    if print_cmd:
+        print (' '.join(arg_list))
+
+    exc    = None
+    result = 0
+    output = ''
+    try:
+        if capture_out:
+            output = subprocess.check_output(arg_list).decode()
+        else:
+            result = subprocess.call (arg_list)
+    except Exception as ex:
+        result = 1
+        exc    = ex
+
+    if result:
+        if not print_cmd:
+            print ('Error in running process:\n  %s' % ' '.join(arg_list))
+        if exc is None:
+            sys.exit(1)
+        else:
+            raise exc
+
+    return output
+
+
+def check_files_exist (base_name_list, dir = '', ext = ''):
+    for each in base_name_list:
+        if not os.path.exists (os.path.join (dir, each + ext)):
+            return False
+    return True
+
+
+def get_visual_studio_info ():
+
+    toolchain        = ''
+    toolchain_prefix = ''
+    toolchain_path   = ''
+    toolchain_ver    = ''
+
+    # check new Visual Studio Community version first
+    vswhere_path = "%s/Microsoft Visual Studio/Installer/vswhere.exe" % os.environ['ProgramFiles(x86)']
+    if os.path.exists (vswhere_path):
+        cmd = [vswhere_path, '-all', '-property', 'installationPath']
+        lines = run_process (cmd, capture_out = True)
+        vscommon_path = ''
+        for each in lines.splitlines ():
+            each = each.strip()
+            if each and os.path.isdir(each):
+                vscommon_path = each
+        vcver_file = vscommon_path + '\\VC\\Auxiliary\\Build\\Microsoft.VCToolsVersion.default.txt'
+        if os.path.exists(vcver_file):
+            for vs_ver in ['2019', '2017']:
+                check_path = '\\Microsoft Visual Studio\\%s\\' % vs_ver
+                if check_path in vscommon_path:
+                    toolchain_ver    = get_file_data (vcver_file, 'r').strip()
+                    toolchain_prefix = 'VS%s_PREFIX' % (vs_ver)
+                    toolchain_path   = vscommon_path + '\\VC\\Tools\\MSVC\\%s\\' % toolchain_ver
+                    toolchain='VS%s' % (vs_ver)
+                    break
+
+    if toolchain == '':
+        vs_ver_list = [
+            ('2015', 'VS140COMNTOOLS'),
+            ('2013', 'VS120COMNTOOLS')
+        ]
+        for vs_ver, vs_tool in vs_ver_list:
+            if vs_tool in os.environ:
+                toolchain        ='VS%s%s' % (vs_ver, 'x86')
+                toolchain_prefix = 'VS%s_PREFIX' % (vs_ver)
+                toolchain_path   = os.path.join(os.environ[vs_tool], '..//..//')
+                toolchain_ver    = vs_ver
+                parts   = os.environ[vs_tool].split('\\')
+                vs_node = 'Microsoft Visual Studio '
+                for part in parts:
+                    if part.startswith(vs_node):
+                        toolchain_ver = part[len(vs_node):]
+                break
+
+    return (toolchain, toolchain_prefix, toolchain_path, toolchain_ver)
+
+
+def rebuild_basetools ():
+    exe_list = 'GenFfs  GenFv  GenFw  GenSec LzmaCompress'.split()
+    ret = 0
+    workspace = os.environ['WORKSPACE']
+
+    cmd = [sys.executable, '-c', 'import sys; import platform; print(", ".join([sys.executable, platform.python_version()]))']
+    py_out = run_process (cmd, capture_out = True)
+    parts  = py_out.split(',')
+    if len(parts) > 1:
+        py_exe, py_ver = parts
+        os.environ['PYTHON_COMMAND'] = py_exe
+        print ('Using %s, Version %s' % (os.environ['PYTHON_COMMAND'], py_ver.rstrip()))
+    else:
+        os.environ['PYTHON_COMMAND'] = 'python'
+
+    if os.name == 'posix':
+        if not check_files_exist (exe_list, os.path.join(workspace, 'BaseTools', 'Source', 'C', 'bin')):
+            ret = subprocess.call(['make', '-C', 'BaseTools'])
+
+    elif os.name == 'nt':
+
+        if not check_files_exist (exe_list, os.path.join(workspace, 'BaseTools', 'Bin', 'Win32'), '.exe'):
+            print ("Could not find pre-built BaseTools binaries, try to rebuild BaseTools ...")
+            ret = run_process (['BaseTools\\toolsetup.bat', 'forcerebuild'])
+
+    if ret:
+        print ("Build BaseTools failed, please check required build environment and utilities !")
+        sys.exit(1)
+
+
+def prep_env():
+    work_dir = os.path.dirname(os.path.realpath(__file__))
+    os.chdir(work_dir)
+    if sys.platform == 'darwin':
+        toolchain = 'XCODE5'
+        os.environ['PATH'] = os.environ['PATH'] + ':' + os.path.join(work_dir, 'BaseTools/BinWrappers/PosixLike')
+        clang_ver = run_process (['clang', '-dumpversion'], capture_out = True)
+        clang_ver = clang_ver.strip()
+        toolchain_ver = clang_ver
+    elif os.name == 'posix':
+        toolchain = 'GCC49'
+        gcc_ver = subprocess.Popen(['gcc', '-dumpversion'], stdout=subprocess.PIPE)
+        (gcc_ver, err) = subprocess.Popen(['sed', 's/\\..*//'], stdin=gcc_ver.stdout, stdout=subprocess.PIPE).communicate()
+        if int(gcc_ver) > 4:
+            toolchain = 'GCC5'
+
+        os.environ['PATH'] = os.environ['PATH'] + ':' + os.path.join(work_dir, 'BaseTools/BinWrappers/PosixLike')
+        toolchain_ver = gcc_ver
+    elif os.name == 'nt':
+        os.environ['PATH'] = os.environ['PATH'] + ';' + os.path.join(work_dir, 'BaseTools\\Bin\\Win32')
+        os.environ['PATH'] = os.environ['PATH'] + ';' + os.path.join(work_dir, 'BaseTools\\BinWrappers\\WindowsLike')
+        os.environ['PYTHONPATH'] = os.path.join(work_dir, 'BaseTools', 'Source', 'Python')
+
+        toolchain, toolchain_prefix, toolchain_path, toolchain_ver = get_visual_studio_info ()
+        if toolchain:
+            os.environ[toolchain_prefix] = toolchain_path
+        else:
+            print("Could not find supported Visual Studio version !")
+            sys.exit(1)
+        if 'NASM_PREFIX' not in os.environ:
+            os.environ['NASM_PREFIX'] = "C:\\Nasm\\"
+        if 'OPENSSL_PATH' not in os.environ:
+            os.environ['OPENSSL_PATH'] = "C:\\Openssl\\"
+        if 'IASL_PREFIX' not in os.environ:
+            os.environ['IASL_PREFIX'] = "C:\\ASL\\"
+    else:
+        print("Unsupported operating system !")
+        sys.exit(1)
+
+    print ('Using %s, Version %s' % (toolchain, toolchain_ver))
+
+    # Update Environment vars
+    os.environ['EDK_TOOLS_PATH'] = os.path.join(work_dir, 'BaseTools')
+    os.environ['BASE_TOOLS_PATH'] = os.path.join(work_dir, 'BaseTools')
+    if 'WORKSPACE' not in os.environ:
+        os.environ['WORKSPACE'] = work_dir
+    os.environ['CONF_PATH']     = os.path.join(os.environ['WORKSPACE'], 'Conf')
+    os.environ['TOOL_CHAIN']    = toolchain
+
+    return (work_dir, toolchain)
+
+
+def Fatal(msg):
+    sys.stdout.flush()
+    raise Exception(msg)
+
+
+def CopyFileList (copy_list, fsp_dir, sbl_dir):
+    print ('Copy FSP into Slim Bootloader source tree ...')
+    for src_path, dst_path in copy_list:
+        src_path = os.path.join (fsp_dir, src_path)
+        dst_path = os.path.join (sbl_dir, dst_path)
+        if not os.path.exists(os.path.dirname(dst_path)):
+            os.makedirs(os.path.dirname(dst_path))
+        print ('Copy:  %s\n  To:  %s' % (os.path.abspath(src_path), os.path.abspath(dst_path)))
+        shutil.copy (src_path, dst_path)
+    print ('Done\n')
+
+
+def Prebuild(target, toolchain):
+
+    rebuild_basetools ()
+
+    workspace = os.environ['WORKSPACE']
+    if not os.path.exists(os.path.join(workspace, 'Conf')):
+        os.makedirs(os.path.join(workspace, 'Conf'))
+    for name in ['target', 'tools_def', 'build_rule']:
+        txt_file = os.path.join(workspace, 'Conf/%s.txt' % name)
+        if not os.path.exists(txt_file):
+            shutil.copy (
+              os.path.join(workspace, 'BaseTools/Conf/%s.template' % name),
+              os.path.join(workspace, 'Conf/%s.txt' % name))
+
+    cmd = '%s -p QemuFspPkg/QemuFspPkg.dsc -m QemuFspPkg/FspHeader/FspHeader.inf -a IA32 -b %s -t %s -DCFG_PREBUILD' % (
+        'build' if os.name == 'posix' else 'build.bat', target, toolchain)
+    ret = subprocess.call(cmd.split(' '))
+    if ret:
+        Fatal('Failed to prebuild QEMU FSP !')
+
+    FspGuid = {
+        'FspTUpdGuid'       : '34686CA3-34F9-4901-B82A-BA630F0714C6',
+        'FspMUpdGuid'       : '39A250DB-E465-4DD1-A2AC-E2BD3C0E2385',
+        'FspSUpdGuid'       : 'CAE3605B-5B34-4C85-B3D7-27D54273C40F'
+    }
+
+    # !!!!!!!! Update VPD/UPD Information !!!!!!!!
+    print('Preparing VPD/UPD Information...')
+
+    pkgname = 'QemuFspPkg'
+    cmd = 'python %s/IntelFsp2Pkg/Tools/GenCfgOpt.py UPDTXT %s/%s.dsc Build/%s/%s_%s/FV' % (
+           workspace, pkgname, pkgname, pkgname, target, toolchain)
+    ret = subprocess.call(cmd.split(' '))
+    if not (ret == 0 or ret == 256):
+        Fatal('Failed to generate UPD txt file !')
+
+    print('UPD TXT file was generated successfully !')
+
+    print('Generate UPD Header File ...')
+    bdpgpath = 'BPDG' if os.name == 'posix' else 'BPDG.bat'
+
+    fvdir = 'Build/%s/%s_%s/FV' % (pkgname, target, toolchain)
+    for fspcomp in FspGuid:
+        fspguid = FspGuid[fspcomp]
+        cmd = '%s %s/%s.txt' % (bdpgpath, fvdir, fspguid)
+        cmd = cmd + ' -o %s/%s.bin' % (fvdir, fspguid)
+        cmd = cmd + ' -m %s/%s.map' % (fvdir, fspguid)
+        filepath = '%s/%s/%s.bin' % (workspace, fvdir, fspguid)
+        if os.path.exists(filepath):
+            os.remove(filepath)
+        ret = subprocess.call(cmd.split(' '))
+        if ret:
+            Fatal('Failed to generate UPD bin file !')
+
+    cmd = 'python %s/IntelFsp2Pkg/Tools/GenCfgOpt.py HEADER %s/%s.dsc Build/%s/%s_%s/FV %s/Include/BootLoaderPlatformData.h' % (
+          workspace, pkgname, pkgname, pkgname, target, toolchain, pkgname)
+    ret = subprocess.call(cmd.split(' '))
+    if ret and (ret != 256):
+        Fatal('Failed to generate UPD header file !')
+
+    print('Generate BSF File ...')
+    cmd = 'python %s/IntelFsp2Pkg/Tools/GenCfgOpt.py GENBSF %s/%s.dsc Build/%s/%s_%s/FV %s/QemuFsp.bsf' % (
+          workspace, pkgname, pkgname, pkgname, target, toolchain, fvdir)
+    ret = subprocess.call(cmd.split(' '))
+    if ret and (ret != 256):
+        Fatal('Failed to generate UPD BSF file !')
+
+    for fliename in ['FspUpd.h', 'FsptUpd.h', 'FspmUpd.h', 'FspsUpd.h']:
+        shutil.copyfile('%s/%s' % (fvdir, fliename), '%s/Include/%s'%(pkgname, fliename))
+    print('End of PreBuild...')
+
+
+def Build (target, toolchain):
+    cmd = '%s -p QemuFspPkg/QemuFspPkg.dsc -a IA32 -b %s -t %s -y Report%s.log' % (
+        'build' if os.name == 'posix' else 'build.bat', target, toolchain, target)
+    ret = subprocess.call(cmd.split(' '))
+    if ret:
+        Fatal('Failed to do Build QEMU FSP!')
+
+    print('End of Build...')
+
+
+def PostBuild (target, toolchain):
+
+    print ('Start of PostBuild ...')
+
+    patchfv = 'IntelFsp2Pkg/Tools/PatchFv.py'
+    fvdir   = 'Build/QemuFspPkg/%s_%s/FV' % (target, toolchain)
+
+    cmd1 = [
+           "0x0000,            _BASE_FSP-T_,                                                                                       @Temporary Base",
+           "<[0x0000]>+0x00AC, [<[0x0000]>+0x0020],                                                                                @FSP-T Size",
+           "<[0x0000]>+0x00B0, [0x0000],                                                                                           @FSP-T Base",
+           "<[0x0000]>+0x00B4, ([<[0x0000]>+0x00B4] & 0xFFFFFFFF) | 0x0001,                                                        @FSP-T Image Attribute",
+           "<[0x0000]>+0x00B6, ([<[0x0000]>+0x00B6] & 0xFFFF0FFC) | 0x1000 | 0x0001 | 0x0002,                                      @FSP-T Component Attribute",
+           "<[0x0000]>+0x00B8, 70BCF6A5-FFB1-47D8-B1AE-EFE5508E23EA:0x1C - <[0x0000]>,                                             @FSP-T CFG Offset",
+           "<[0x0000]>+0x00BC, [70BCF6A5-FFB1-47D8-B1AE-EFE5508E23EA:0x14] & 0xFFFFFF - 0x001C,                                    @FSP-T CFG Size",
+           "<[0x0000]>+0x00C4, FspSecCoreT:_TempRamInitApi - [0x0000],                                                             @TempRamInit API",
+           "0x0000,            0x00000000,                                                                                         @Restore the value",
+           "FspSecCoreT:_FspInfoHeaderRelativeOff, FspSecCoreT:_AsmGetFspInfoHeader - {912740BE-2284-4734-B971-84B027353F0C:0x1C}, @FSP-T Header Offset"
+           ]
+
+    cmd2 = [
+         "0x0000,            _BASE_FSP-M_,                                                                                       @Temporary Base",
+         "<[0x0000]>+0x00AC, [<[0x0000]>+0x0020],                                                                                @FSP-M Size",
+         "<[0x0000]>+0x00B0, [0x0000],                                                                                           @FSP-M Base",
+         "<[0x0000]>+0x00B4, ([<[0x0000]>+0x00B4] & 0xFFFFFFFF) | 0x0001,                                                        @FSP-M Image Attribute",
+         "<[0x0000]>+0x00B6, ([<[0x0000]>+0x00B6] & 0xFFFF0FFC) | 0x2000 | 0x0001 | 0x0002,                                      @FSP-M Component Attribute",
+         "<[0x0000]>+0x00B8, D5B86AEA-6AF7-40D4-8014-982301BC3D89:0x1C - <[0x0000]>,                                             @FSP-M CFG Offset",
+         "<[0x0000]>+0x00BC, [D5B86AEA-6AF7-40D4-8014-982301BC3D89:0x14] & 0xFFFFFF - 0x001C,                                    @FSP-M CFG Size",
+         "<[0x0000]>+0x00D0, FspSecCoreM:_FspMemoryInitApi - [0x0000],                                                           @MemoryInitApi API",
+         "<[0x0000]>+0x00D4, FspSecCoreM:_TempRamExitApi - [0x0000],                                                             @TempRamExit API",
+         "FspSecCoreM:_FspPeiCoreEntryOff, PeiCore:__ModuleEntryPoint - [0x0000],                                                @PeiCore Entry",
+         "0x0000,            0x00000000,                                                                                         @Restore the value",
+         "FspSecCoreM:_FspInfoHeaderRelativeOff, FspSecCoreM:_AsmGetFspInfoHeader - {912740BE-2284-4734-B971-84B027353F0C:0x1C}, @FSP-M Header Offset"
+         ]
+
+    cmd3 = [
+         "0x0000,            _BASE_FSP-S_,                                                                                       @Temporary Base",
+         "<[0x0000]>+0x00AC, [<[0x0000]>+0x0020],                                                                                @FSP-S Size",
+         "<[0x0000]>+0x00B0, [0x0000],                                                                                           @FSP-S Base",
+         "<[0x0000]>+0x00B4, ([<[0x0000]>+0x00B4] & 0xFFFFFFFF) | 0x0001,                                                        @FSP-S Image Attribute",
+         "<[0x0000]>+0x00B6, ([<[0x0000]>+0x00B6] & 0xFFFF0FFC) | 0x3000 | 0x0001 | 0x0002                      ,                @FSP-S Component Attribute",
+         "<[0x0000]>+0x00B8, E3CD9B18-998C-4F76-B65E-98B154E5446F:0x1C - <[0x0000]>,                                             @FSP-S CFG Offset",
+         "<[0x0000]>+0x00BC, [E3CD9B18-998C-4F76-B65E-98B154E5446F:0x14] & 0xFFFFFF - 0x001C,                                    @FSP-S CFG Size",
+         "<[0x0000]>+0x00D8, FspSecCoreS:_FspSiliconInitApi - [0x0000],                                                          @SiliconInit API",
+         "<[0x0000]>+0x00CC, FspSecCoreS:_NotifyPhaseApi - [0x0000],                                                             @NotifyPhase API",
+         "0x0000,            0x00000000,                                                                                         @Restore the value",
+         "FspSecCoreS:_FspInfoHeaderRelativeOff, FspSecCoreS:_AsmGetFspInfoHeader - {912740BE-2284-4734-B971-84B027353F0C:0x1C}, @FSP-S Header Offset"
+         ]
+
+    for fspt, cmd in [('T', cmd1), ('M', cmd2), ('S',cmd3)]:
+        print ('Patch FSP-%s Image ...' % fspt)
+        line = ['python', patchfv, fvdir, 'FSP-%s:QEMUFSP' % fspt]
+        line.extend(cmd)
+        ret = subprocess.call(line)
+        if ret:
+            Fatal('Failed to do PostBuild QEMU FSP!')
+
+    copy_list = [
+        ('QEMUFSP.fd',  'QEMU_FSP_%s.fd' % target),
+        ('QemuFsp.bsf', 'QEMU_FSP.bsf'),
+        ('FspUpd.h',    'FspUpd.h'),
+        ('FsptUpd.h',   'FsptUpd.h'),
+        ('FspmUpd.h',   'FspmUpd.h'),
+        ('FspsUpd.h',   'FspsUpd.h'),
+    ]
+    CopyFileList (copy_list, fvdir, 'BuildFsp')
+
+    print('End of PostBuild...')
+
+
+def Main():
+    curr_dir      = os.path.dirname (os.path.realpath(__file__))
+    sbl_dir       = os.path.abspath (os.path.join(curr_dir, '../..'))
+    fsp_repo_dir  = os.path.abspath (os.path.join(curr_dir, '../../../IntelFsp'))
+    qemu_repo_dir = os.path.abspath (os.path.join(curr_dir, '../../../QemuFsp'))
+
+    if len(sys.argv) < 2:
+        target = 'DEBUG'
+    else:
+        if sys.argv[1] == '/r':
+            target = 'RELEASE'
+        elif sys.argv[1] == '/d':
+            target = 'DEBUG'
+        else:
+            print ('Unknown target %s !' % sys.argv[1])
+            return -1
+
+    workspace, toolchain = prep_env()
+    os.environ['WORKSPACE'] = workspace
+    Prebuild  (target, toolchain)
+    Build     (target, toolchain)
+    PostBuild (target, toolchain)
+
+    return 0
+
+
+if __name__ == '__main__':
+    sys.exit(Main())
diff --git a/IntelFsp2Pkg/Tools/PatchFv.py b/IntelFsp2Pkg/Tools/PatchFv.py
index 112de4077a..fe6d29426e 100644
--- a/IntelFsp2Pkg/Tools/PatchFv.py
+++ b/IntelFsp2Pkg/Tools/PatchFv.py
@@ -423,6 +423,13 @@ class Symbols:
             matchKeyGroupIndex = 2
             matchSymbolGroupIndex  = 1
             prefix = '_'
+        elif reportLine.strip().find("XCODE") != -1:
+            #XCODE
+            #0x00001E29      0x00000013      [ 53] __ModuleEntryPoint
+            patchMapFileMatchString = "(0x[0-9a-fA-F]{8})\s+0x[0-9a-fA-F]{8}\s+\[.*\]\s+(\w+)$"
+            matchKeyGroupIndex = 2
+            matchSymbolGroupIndex  = 1
+            prefix = ''
         else:
             #MSFT
             #0003:00000190       _gComBase                  00007a50     SerialPo
diff --git a/QemuFspPkg/BuildFv.cmd b/QemuFspPkg/BuildFv.cmd
new file mode 100644
index 0000000000..a535d68b7c
--- /dev/null
+++ b/QemuFspPkg/BuildFv.cmd
@@ -0,0 +1,248 @@
+@REM ## @file
+@REM #  FSP build script
+@REM #
+@REM #  Copyright (c) 2017 - 2018, Intel Corporation. All rights reserved.<BR>
+@REM #
+@REM #  This program and the accompanying materials
+@REM #  are licensed and made available under the terms and conditions of the BSD License
+@REM #  which accompanies this distribution. The full text of the license may be found at
+@REM #  http://opensource.org/licenses/bsd-license.php.
+@REM #  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+@REM #  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+@REM #
+@REM ##
+
+@echo off
+
+set FSP_PKG_NAME=QemuFspPkg
+set FSP_BASENAME=QemuFsp
+set TOOL_CHAIN_TAG=VS2015x86
+
+@if /I "%1"=="/h" goto Usage
+@if /I "%1"=="/?" goto Usage
+
+@if not defined WORKSPACE (
+  call %~dp0\..\edksetup.bat
+  set NASM_PREFIX=C:\Nasm\
+  @echo off
+)
+
+set MISC_FLAGS=
+set FSP_BD_COMMON=-p %FSP_PKG_NAME%\%FSP_PKG_NAME%.dsc %MISC_FLAGS% -a IA32 -n 4 -t %TOOL_CHAIN_TAG% -Y PCD -Y LIBRARY
+
+if /I "%1"=="/clean" goto Clean
+if /I "%1"=="/r" goto ReleaseBuild
+if /I "%1"=="/d" goto DebugBuild
+
+if /I "%1"=="" (
+  goto DebugBuild
+) else (
+  echo.
+  echo  ERROR: "%1" is not valid parameter.
+  goto Usage
+)
+
+:Clean
+echo Removing Build and Conf directories ...
+if exist Build rmdir Build /s /q
+if exist Conf  rmdir Conf  /s /q
+if exist *.log  del *.log /q /f
+set WORKSPACE=
+set EDK_TOOLS_PATH=
+goto End
+
+:ReleaseBuild
+set  BD_TARGET=RELEASE
+set  BD_MACRO=%MISC_FLAGS%
+set  BD_ARGS=%FSP_BD_COMMON% -b RELEASE %BD_MACRO% -y ReportRelease.log
+set  FSP_BUILD_TYPE=0x0001
+set  FSP_RELEASE_TYPE=0x0002
+goto Build
+
+:DebugBuild
+set  BD_TARGET=DEBUG
+set  BD_MACRO=%MISC_FLAGS%
+set  BD_ARGS=%FSP_BD_COMMON% -b DEBUG  %BD_MACRO% -y ReportDebug.log
+set  FSP_BUILD_TYPE=0x0000
+set  FSP_RELEASE_TYPE=0x0000
+goto Build
+
+
+:Build
+echo PREBUILD
+build  -m %FSP_PKG_NAME%\FspHeader\FspHeader.inf %BD_ARGS% -DCFG_PREBUILD
+if ERRORLEVEL 1 exit /b 1
+call :PreBuild  CALL_RET
+if "%CALL_RET%"=="1" exit /b 1
+echo BUILD
+build  %BD_ARGS%
+if ERRORLEVEL 1 exit /b 1
+echo POSTBUILD
+call :PostBuild
+goto End
+
+:Usage
+echo.
+echo  Usage: "%0 [/h | /? | /r | /d | /clean]"
+echo.
+goto End
+
+:PreBuild
+echo Start of PreBuild ...
+
+set %~1=1
+
+@REM @todo update BPDG.exe tool to use FSP_C_UPD_GUID
+set TOOL_MACRO=%BD_MACRO% -DFSP_VER=%FSP_VER%
+set FSP_T_UPD_GUID=34686CA3-34F9-4901-B82A-BA630F0714C6
+set FSP_M_UPD_GUID=39A250DB-E465-4DD1-A2AC-E2BD3C0E2385
+set FSP_S_UPD_GUID=CAE3605B-5B34-4C85-B3D7-27D54273C40F
+python %WORKSPACE%/IntelFsp2Pkg/Tools/GenCfgOpt.py UPDTXT ^
+     %FSP_PKG_NAME%\%FSP_PKG_NAME%.dsc ^
+     Build\%FSP_PKG_NAME%\%BD_TARGET%_%TOOL_CHAIN_TAG%\FV ^
+     %TOOL_MACRO%
+if "%ERRORLEVEL%"=="256" (
+  REM  DSC is not changed, no need to recreate MAP and BIN file
+) else (
+  if ERRORLEVEL 1 goto:PreBuildFail
+  echo UPD TXT file was generated successfully !
+
+  echo Generate UPD Header File ...
+  for %%A in (%FSP_T_UPD_GUID% %FSP_M_UPD_GUID% %FSP_S_UPD_GUID%) do (
+    echo %%A
+    del /q /f Build\%FSP_PKG_NAME%\%BD_TARGET%_%TOOL_CHAIN_TAG%\FV\%%A.bin ^
+            Build\%FSP_PKG_NAME%\%BD_TARGET%_%TOOL_CHAIN_TAG%\FV\%%A.map 2>nul
+    BaseTools\Bin\Win32\BPDG.exe ^
+       Build\%FSP_PKG_NAME%\%BD_TARGET%_%TOOL_CHAIN_TAG%\FV\%%%A.txt ^
+       -o Build\%FSP_PKG_NAME%\%BD_TARGET%_%TOOL_CHAIN_TAG%\FV\%%A.bin ^
+       -m Build\%FSP_PKG_NAME%\%BD_TARGET%_%TOOL_CHAIN_TAG%\FV\%%A.map
+    if ERRORLEVEL 1 goto:PreBuildFail
+  )
+)
+
+python %WORKSPACE%/IntelFsp2Pkg/Tools/GenCfgOpt.py HEADER ^
+         %FSP_PKG_NAME%\%FSP_PKG_NAME%.dsc ^
+         Build\%FSP_PKG_NAME%\%BD_TARGET%_%TOOL_CHAIN_TAG%\FV ^
+         %FSP_PKG_NAME%\Include\BootLoaderPlatformData.h ^
+         %TOOL_MACRO%
+if "%ERRORLEVEL%"=="256" (
+    REM  No need to recreate header file
+) else (
+    if ERRORLEVEL 1 goto:PreBuildFail
+    echo Upd header file was generated successfully !
+
+    echo Generate BSF File ...
+    python %WORKSPACE%/IntelFsp2Pkg/Tools/GenCfgOpt.py GENBSF ^
+         %FSP_PKG_NAME%\%FSP_PKG_NAME%.dsc ^
+         Build\%FSP_PKG_NAME%\%BD_TARGET%_%TOOL_CHAIN_TAG%\FV ^
+         Build\%FSP_PKG_NAME%\%BD_TARGET%_%TOOL_CHAIN_TAG%\FV\QemuFsp.bsf ^
+         %TOOL_MACRO%
+
+    if ERRORLEVEL 1 goto:PreBuildFail
+    echo BSF file was generated successfully !
+
+    if exist "Build\%FSP_PKG_NAME%\%BD_TARGET%_%TOOL_CHAIN_TAG%\FV\FspUpd.h" (
+      attrib -r %FSP_PKG_NAME%\Include\FspUpd.h
+      copy /y Build\%FSP_PKG_NAME%\%BD_TARGET%_%TOOL_CHAIN_TAG%\FV\FspUpd.h %FSP_PKG_NAME%\Include\FspUpd.h
+      )
+    if exist "Build\%FSP_PKG_NAME%\%BD_TARGET%_%TOOL_CHAIN_TAG%\FV\FsptUpd.h" (
+      attrib -r %FSP_PKG_NAME%\Include\FsptUpd.h
+      copy /y Build\%FSP_PKG_NAME%\%BD_TARGET%_%TOOL_CHAIN_TAG%\FV\FsptUpd.h %FSP_PKG_NAME%\Include\FsptUpd.h
+      )
+    if exist "Build\%FSP_PKG_NAME%\%BD_TARGET%_%TOOL_CHAIN_TAG%\FV\FspmUpd.h" (
+      attrib -r %FSP_PKG_NAME%\Include\FspmUpd.h
+      copy /y Build\%FSP_PKG_NAME%\%BD_TARGET%_%TOOL_CHAIN_TAG%\FV\FspmUpd.h %FSP_PKG_NAME%\Include\FspmUpd.h
+      )
+    if exist "Build\%FSP_PKG_NAME%\%BD_TARGET%_%TOOL_CHAIN_TAG%\FV\FspsUpd.h" (
+      attrib -r %FSP_PKG_NAME%\Include\FspsUpd.h
+      copy /y Build\%FSP_PKG_NAME%\%BD_TARGET%_%TOOL_CHAIN_TAG%\FV\FspsUpd.h %FSP_PKG_NAME%\Include\FspsUpd.h
+      )
+
+)
+
+:PreBuildRet
+set %~1=0
+echo End of PreBuild ...
+echo.
+goto:EOF
+
+:PreBuildFail
+del /q /f Build\%FSP_PKG_NAME%\%BD_TARGET%_%TOOL_CHAIN_TAG%\FV\FspUpd.h
+del /q /f Build\%FSP_PKG_NAME%\%BD_TARGET%_%TOOL_CHAIN_TAG%\FV\FsptUpd.h
+del /q /f Build\%FSP_PKG_NAME%\%BD_TARGET%_%TOOL_CHAIN_TAG%\FV\FspmUpd.h
+del /q /f Build\%FSP_PKG_NAME%\%BD_TARGET%_%TOOL_CHAIN_TAG%\FV\FspsUpd.h
+
+echo.
+(goto) 2>nul & endlocal & exit /b 1
+goto:EOF
+
+:PostBuild
+echo Start of PostBuild ...
+
+echo Patch FSP-T Image ...
+python %WORKSPACE%\IntelFsp2Pkg\Tools\PatchFv.py ^
+     Build\%FSP_PKG_NAME%\%BD_TARGET%_%TOOL_CHAIN_TAG%\FV ^
+     FSP-T:%FSP_BASENAME%  ^
+     "0x0000,            _BASE_FSP-T_,                                                                                       @Temporary Base" ^
+     "<[0x0000]>+0x00AC, [<[0x0000]>+0x0020],                                                                                @FSP-T Size" ^
+     "<[0x0000]>+0x00B0, [0x0000],                                                                                           @FSP-T Base" ^
+     "<[0x0000]>+0x00B4, ([<[0x0000]>+0x00B4] & 0xFFFFFFFF) | 0x0001,                                                        @FSP-T Image Attribute" ^
+     "<[0x0000]>+0x00B6, ([<[0x0000]>+0x00B6] & 0xFFFF0FFC) | 0x1000 | %FSP_BUILD_TYPE% | %FSP_RELEASE_TYPE%,                @FSP-T Component Attribute" ^
+     "<[0x0000]>+0x00B8, 70BCF6A5-FFB1-47D8-B1AE-EFE5508E23EA:0x1C - <[0x0000]>,                                             @FSP-T CFG Offset" ^
+     "<[0x0000]>+0x00BC, [70BCF6A5-FFB1-47D8-B1AE-EFE5508E23EA:0x14] & 0xFFFFFF - 0x001C,                                    @FSP-T CFG Size" ^
+     "<[0x0000]>+0x00C4, FspSecCoreT:_TempRamInitApi - [0x0000],                                                             @TempRamInit API" ^
+     "0x0000,            0x00000000,                                                                                         @Restore the value" ^
+     "FspSecCoreT:_FspInfoHeaderRelativeOff, FspSecCoreT:_AsmGetFspInfoHeader - {912740BE-2284-4734-B971-84B027353F0C:0x1C}, @FSP-T Header Offset"
+if ERRORLEVEL 1 goto:PreBuildFail
+
+echo Patch FSP-M Image ...
+python %WORKSPACE%\IntelFsp2Pkg\Tools\PatchFv.py ^
+     Build\%FSP_PKG_NAME%\%BD_TARGET%_%TOOL_CHAIN_TAG%\FV ^
+     FSP-M:%FSP_BASENAME%  ^
+     "0x0000,            _BASE_FSP-M_,                                                                                       @Temporary Base" ^
+     "<[0x0000]>+0x00AC, [<[0x0000]>+0x0020],                                                                                @FSP-M Size" ^
+     "<[0x0000]>+0x00B0, [0x0000],                                                                                           @FSP-M Base" ^
+     "<[0x0000]>+0x00B4, ([<[0x0000]>+0x00B4] & 0xFFFFFFFF) | 0x0001,                                                        @FSP-M Image Attribute" ^
+     "<[0x0000]>+0x00B6, ([<[0x0000]>+0x00B6] & 0xFFFF0FFC) | 0x2000 | %FSP_BUILD_TYPE% | %FSP_RELEASE_TYPE%,                @FSP-M Component Attribute" ^
+     "<[0x0000]>+0x00B8, D5B86AEA-6AF7-40D4-8014-982301BC3D89:0x1C - <[0x0000]>,                                             @FSP-M CFG Offset" ^
+     "<[0x0000]>+0x00BC, [D5B86AEA-6AF7-40D4-8014-982301BC3D89:0x14] & 0xFFFFFF - 0x001C,                                    @FSP-M CFG Size" ^
+     "<[0x0000]>+0x00D0, FspSecCoreM:_FspMemoryInitApi - [0x0000],                                                           @MemoryInitApi API" ^
+     "<[0x0000]>+0x00D4, FspSecCoreM:_TempRamExitApi - [0x0000],                                                             @TempRamExit API" ^
+     "FspSecCoreM:_FspPeiCoreEntryOff, PeiCore:__ModuleEntryPoint - [0x0000],                                                @PeiCore Entry" ^
+     "0x0000,            0x00000000,                                                                                         @Restore the value" ^
+     "FspSecCoreM:_FspInfoHeaderRelativeOff, FspSecCoreM:_AsmGetFspInfoHeader - {912740BE-2284-4734-B971-84B027353F0C:0x1C}, @FSP-M Header Offset"
+if ERRORLEVEL 1 goto:PreBuildFail
+
+echo Patch FSP-S Image ...
+python %WORKSPACE%\IntelFsp2Pkg\Tools\PatchFv.py ^
+     Build\%FSP_PKG_NAME%\%BD_TARGET%_%TOOL_CHAIN_TAG%\FV ^
+     FSP-S:%FSP_BASENAME%  ^
+     "0x0000,            _BASE_FSP-S_,                                                                                       @Temporary Base" ^
+     "<[0x0000]>+0x00AC, [<[0x0000]>+0x0020],                                                                                @FSP-S Size" ^
+     "<[0x0000]>+0x00B0, [0x0000],                                                                                           @FSP-S Base" ^
+     "<[0x0000]>+0x00B4, ([<[0x0000]>+0x00B4] & 0xFFFFFFFF) | 0x0001,                                                        @FSP-S Image Attribute" ^
+     "<[0x0000]>+0x00B6, ([<[0x0000]>+0x00B6] & 0xFFFF0FFC) | 0x3000 | %FSP_BUILD_TYPE% | %FSP_RELEASE_TYPE%,                @FSP-S Component Attribute" ^
+     "<[0x0000]>+0x00B8, E3CD9B18-998C-4F76-B65E-98B154E5446F:0x1C - <[0x0000]>,                                             @FSP-S CFG Offset" ^
+     "<[0x0000]>+0x00BC, [E3CD9B18-998C-4F76-B65E-98B154E5446F:0x14] & 0xFFFFFF - 0x001C,                                    @FSP-S CFG Size" ^
+     "<[0x0000]>+0x00D8, FspSecCoreS:_FspSiliconInitApi - [0x0000],                                                          @SiliconInit API" ^
+     "<[0x0000]>+0x00CC, FspSecCoreS:_NotifyPhaseApi - [0x0000],                                                             @NotifyPhase API" ^
+     "0x0000,            0x00000000,                                                                                         @Restore the value" ^
+     "FspSecCoreS:_FspInfoHeaderRelativeOff, FspSecCoreS:_AsmGetFspInfoHeader - {912740BE-2284-4734-B971-84B027353F0C:0x1C}, @FSP-S Header Offset"
+if ERRORLEVEL 1 goto:PreBuildFail
+
+echo Copy Fsp images and FVs to \BuildFsp
+if not exist %WORKSPACE%\BuildFsp @mkdir %WORKSPACE%\BuildFsp
+copy /y Build\%FSP_PKG_NAME%\%BD_TARGET%_%TOOL_CHAIN_TAG%\FV\QEMUFSP.fd  %WORKSPACE%\BuildFsp\QEMU_FSP.fd
+copy /y Build\%FSP_PKG_NAME%\%BD_TARGET%_%TOOL_CHAIN_TAG%\FV\QEMUFSP.bsf %WORKSPACE%\BuildFsp\QEMU_FSP.bsf
+copy /y Build\%FSP_PKG_NAME%\%BD_TARGET%_%TOOL_CHAIN_TAG%\FV\FspUpd.h    %WORKSPACE%\BuildFsp\FspUpd.h
+copy /y Build\%FSP_PKG_NAME%\%BD_TARGET%_%TOOL_CHAIN_TAG%\FV\FsptUpd.h   %WORKSPACE%\BuildFsp\FsptUpd.h
+copy /y Build\%FSP_PKG_NAME%\%BD_TARGET%_%TOOL_CHAIN_TAG%\FV\FspmUpd.h   %WORKSPACE%\BuildFsp\FspmUpd.h
+copy /y Build\%FSP_PKG_NAME%\%BD_TARGET%_%TOOL_CHAIN_TAG%\FV\FspsUpd.h   %WORKSPACE%\BuildFsp\FspsUpd.h
+
+
+echo Patch is DONE
+
+goto:EOF
+
+:End
+echo.
diff --git a/QemuFspPkg/FspDescription/FspDescription.inf b/QemuFspPkg/FspDescription/FspDescription.inf
new file mode 100644
index 0000000000..6b32295f5f
--- /dev/null
+++ b/QemuFspPkg/FspDescription/FspDescription.inf
@@ -0,0 +1,29 @@
+/** @file
+  Text description file for FSP binary
+
+  Copyright (c) 2017 - 2018, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php.
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = FspDescription
+  FILE_GUID                      = D9093578-08EB-44DF-B9D8-D0C1D3D55D96
+  MODULE_TYPE                    = USER_DEFINED
+  VERSION_STRING                 = 1.0
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64 IPF EBC
+#
+
+[Binaries]
+  BIN|FspDescription.txt|*
diff --git a/QemuFspPkg/FspDescription/FspDescription.txt b/QemuFspPkg/FspDescription/FspDescription.txt
new file mode 100644
index 0000000000..b42a4e5095
--- /dev/null
+++ b/QemuFspPkg/FspDescription/FspDescription.txt
@@ -0,0 +1,2 @@
+This FSP supports the following:
+  QEMU Q35/ICH9
diff --git a/QemuFspPkg/FspHeader/FspHeader.aslc b/QemuFspPkg/FspHeader/FspHeader.aslc
new file mode 100644
index 0000000000..47c0b675c3
--- /dev/null
+++ b/QemuFspPkg/FspHeader/FspHeader.aslc
@@ -0,0 +1,90 @@
+/** @file
+  This file defines FSP information header
+
+  Copyright (c) 2017 - 2018, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php.
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+
+#include <PiPei.h>
+#include <Library/PcdLib.h>
+#include <FspEas.h>
+
+#define UINT64_TO_BYTE_ARRAY(x) {(unsigned char)(x),(unsigned char)((x)>>8),(unsigned char)((x)>>16),(unsigned char)((x)>>24),(unsigned char)((x)>>32),(unsigned char)((x)>>40),(unsigned char)((x)>>48),(unsigned char)((x)>>56) }
+
+typedef struct{
+  FSP_INFO_HEADER          FspInfoHeader;
+  FSP_INFO_EXTENDED_HEADER FspInfoExtendedHeader;
+  FSP_PATCH_TABLE          FspPatchTable;
+  UINT32                   FspPatchData0;
+}TABLES;
+
+#define FSP_PRODUCER_ID  "INTELC"
+
+TABLES mTable =
+{
+  {
+    FSP_INFO_HEADER_SIGNATURE,                    // UINT32  Signature  (FSPH)
+    sizeof(FSP_INFO_HEADER),                      // UINT32  HeaderLength;
+    {0x00, 0x00},                                 // UINT8   Reserved1[2];
+    FixedPcdGet8(PcdFspHeaderSpecVersion),        // UINT8   SpecVersion;
+    FixedPcdGet8(PcdFspHeaderRevision),           // UINT8   HeaderRevision;
+    FixedPcdGet32(PcdFspImageRevision),           // UINT32  ImageRevision;
+
+    UINT64_TO_BYTE_ARRAY(
+    FixedPcdGet64(PcdFspImageIdString)),          // CHAR8   ImageId[8];
+
+    0x12345678,                                   // UINT32  ImageSize;
+    0x12345678,                                   // UINT32  ImageBase;
+
+    FixedPcdGet16(PcdFspImageAttributes),         // UINT16  ImageAttribute;
+    FixedPcdGet16(PcdFspComponentAttributes),     // UINT16  ComponentAttribute; Bits[15:12] - 0001b: FSP-T, 0010b: FSP-M, 0011b: FSP-S
+    0x12345678,                                   // UINT32  CfgRegionOffset;
+    0x12345678,                                   // UINT32  CfgRegionSize;
+    0x00000000,                                   // UINT32  Reserved2;
+
+    0x00000000,                                   // UINT32  TempRamInitEntry;
+    0x00000000,                                   // UINT32  Reserved3;
+    0x00000000,                                   // UINT32  NotifyPhaseEntry;
+    0x00000000,                                   // UINT32  FspMemoryInitEntry;
+    0x00000000,                                   // UINT32  TempRamExitEntry;
+    0x00000000,                                   // UINT32  FspSiliconInitEntry;
+  },
+  {
+    FSP_INFO_EXTENDED_HEADER_SIGNATURE,           // UINT32  Signature  (FSPE)
+    sizeof(FSP_INFO_EXTENDED_HEADER),             // UINT32  Length;
+    FSPE_HEADER_REVISION_1,                       // UINT8   Revision;
+    0x00,                                         // UINT8   Reserved;
+    {FSP_PRODUCER_ID},                            // CHAR8   FspProducerId[6];
+    0x00000001,                                   // UINT32  FspProducerRevision;
+    0x00000000,                                   // UINT32  FspProducerDataSize;
+  },
+  {
+    FSP_FSPP_SIGNATURE,                           // UINT32  Signature  (FSPP)
+    sizeof(FSP_PATCH_TABLE),                      // UINT16  Length;
+    FSPP_HEADER_REVISION_1,                       // UINT8   Revision;
+    0x00,                                         // UINT8   Reserved;
+    1                                             // UINT32  PatchEntryNum;
+  },
+    0xFFFFFFFC                                    // UINT32  Patch FVBASE at end of FV
+};
+
+
+VOID*
+ReferenceAcpiTable (
+  VOID
+  )
+{
+  //
+  // Reference the table being generated to prevent the optimizer from
+  // removing the data structure from the executable
+  //
+  return (VOID*)&mTable;
+}
diff --git a/QemuFspPkg/FspHeader/FspHeader.inf b/QemuFspPkg/FspHeader/FspHeader.inf
new file mode 100644
index 0000000000..d5ffe3d433
--- /dev/null
+++ b/QemuFspPkg/FspHeader/FspHeader.inf
@@ -0,0 +1,49 @@
+## @file
+#   FSP information header component.
+#
+#  Copyright (c) 2017 - 2018, Intel Corporation. All rights reserved.<BR>
+#
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution. The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php.
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+#
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = FspHeader
+  FILE_GUID                      = 912740BE-2284-4734-B971-84B027353F0C
+  MODULE_TYPE                    = USER_DEFINED
+  VERSION_STRING                 = 1.0
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64 IPF EBC
+#
+
+[Sources]
+  FspHeader.aslc
+
+[Packages]
+  MdePkg/MdePkg.dec
+  MdeModulePkg/MdeModulePkg.dec
+  IntelFsp2Pkg/IntelFsp2Pkg.dec
+  QemuFspPkg/QemuFspPkg.dec
+
+[Pcd]
+  gIntelFsp2PkgTokenSpaceGuid.PcdFspHeaderSpecVersion
+  gQemuFspPkgTokenSpaceGuid.PcdFspHeaderRevision
+  gQemuFspPkgTokenSpaceGuid.PcdFspImageIdString
+  gQemuFspPkgTokenSpaceGuid.PcdFspImageAttributes
+  gQemuFspPkgTokenSpaceGuid.PcdFspComponentAttributes
+  gQemuFspPkgTokenSpaceGuid.PcdFlashFvFsptBase
+  gQemuFspPkgTokenSpaceGuid.PcdFlashFvFspmBase
+  gQemuFspPkgTokenSpaceGuid.PcdFlashFvFspsBase
+  gQemuFspPkgTokenSpaceGuid.PcdFspImageRevision
+
+[FixedPcd]
+  gIntelFsp2PkgTokenSpaceGuid.PcdFspMaxPatchEntry
diff --git a/QemuFspPkg/FspmInit/FspmInit.c b/QemuFspPkg/FspmInit/FspmInit.c
new file mode 100644
index 0000000000..9420bba30d
--- /dev/null
+++ b/QemuFspPkg/FspmInit/FspmInit.c
@@ -0,0 +1,800 @@
+/** @file
+  FSP-M component implementation.
+
+  Copyright (c) 2017 - 2018, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php.
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include "FspmInit.h"
+#include <Library/FspCommonLib.h>
+
+extern EFI_GUID gFspSiliconFvGuid;
+
+GLOBAL_REMOVE_IF_UNREFERENCED EFI_PEI_PPI_DESCRIPTOR mPpiBootMode = {
+  (EFI_PEI_PPI_DESCRIPTOR_PPI | EFI_PEI_PPI_DESCRIPTOR_TERMINATE_LIST),
+  &gEfiPeiMasterBootModePpiGuid,
+  NULL
+};
+
+EFI_PEI_NOTIFY_DESCRIPTOR mMemoryDiscoveredNotifyList = {
+  (EFI_PEI_PPI_DESCRIPTOR_NOTIFY_DISPATCH | EFI_PEI_PPI_DESCRIPTOR_TERMINATE_LIST),
+  &gEfiPeiMemoryDiscoveredPpiGuid,
+  MemoryDiscoveredPpiNotifyCallback
+};
+
+
+/**
+  Reads 8-bits of CMOS data.
+
+  Reads the 8-bits of CMOS data at the location specified by Index.
+  The 8-bit read value is returned.
+
+  @param  Index  The CMOS location to read.
+
+  @return The value read.
+
+**/
+UINT8
+EFIAPI
+CmosRead8 (
+  IN      UINTN                     Index
+  )
+{
+  IoWrite8 (0x70, (UINT8) Index);
+  return IoRead8 (0x71);
+}
+
+
+/**
+  Writes 8-bits of CMOS data.
+
+  Writes 8-bits of CMOS data to the location specified by Index
+  with the value specified by Value and returns Value.
+
+  @param  Index  The CMOS location to write.
+  @param  Value  The value to write to CMOS.
+
+  @return The value written to CMOS.
+
+**/
+UINT8
+EFIAPI
+CmosWrite8 (
+  IN      UINTN                     Index,
+  IN      UINT8                     Value
+  )
+{
+  IoWrite8 (0x70, (UINT8) Index);
+  IoWrite8 (0x71, Value);
+  return Value;
+}
+
+/**
+  Migrate FSP-M UPD data before destroying CAR.
+
+**/
+VOID
+EFIAPI
+MigrateFspmUpdData (
+  VOID
+ )
+{
+  FSP_INFO_HEADER           *FspInfoHeaderPtr;
+  VOID                      *FspmUpdPtrPostMem;
+  VOID                      *FspmUpdPtrPreMem;
+
+  FspInfoHeaderPtr = GetFspInfoHeader();
+  FspmUpdPtrPostMem = (VOID *)AllocatePages (EFI_SIZE_TO_PAGES ((UINTN)FspInfoHeaderPtr->CfgRegionSize));
+  ASSERT(FspmUpdPtrPostMem != NULL);
+
+  FspmUpdPtrPreMem = (VOID *)GetFspMemoryInitUpdDataPointer ();
+  CopyMem (FspmUpdPtrPostMem, (VOID *)FspmUpdPtrPreMem, (UINTN)FspInfoHeaderPtr->CfgRegionSize);
+
+  //
+  // Update FSP-M UPD pointer in FSP Global Data
+  //
+  SetFspMemoryInitUpdDataPointer((VOID *)FspmUpdPtrPostMem);
+
+  DEBUG ((DEBUG_INFO, "Migrate FSP-M UPD from %x to %x \n", FspmUpdPtrPreMem, FspmUpdPtrPostMem));
+
+}
+
+
+/**
+  This function reports and installs new FV
+
+  @retval     EFI_SUCCESS          The function completes successfully
+**/
+EFI_STATUS
+ReportAndInstallNewFv (
+  VOID
+  )
+{
+  FSP_INFO_HEADER                *FspInfoHeader;
+  EFI_FIRMWARE_VOLUME_HEADER     *FvHeader;
+  UINT8                          *CurPtr;
+  UINT8                          *EndPtr;
+
+  FspInfoHeader = GetFspInfoHeaderFromApiContext();
+  if (FspInfoHeader->Signature != FSP_INFO_HEADER_SIGNATURE) {
+    DEBUG ((DEBUG_ERROR, "The signature of FspInfoHeader getting from API context is invalid at 0x%08X.\n", (UINT32)FspInfoHeader));
+    FspInfoHeader = GetFspInfoHeader();
+  }
+
+  CurPtr = (UINT8 *)FspInfoHeader->ImageBase;
+  EndPtr = CurPtr + FspInfoHeader->ImageSize - 1;
+
+  while (CurPtr < EndPtr) {
+    FvHeader = (EFI_FIRMWARE_VOLUME_HEADER *)CurPtr;
+    if (FvHeader->Signature != EFI_FVH_SIGNATURE) {
+      break;
+    }
+    PeiServicesInstallFvInfoPpi (
+      NULL,
+      (VOID *)FvHeader,
+      (UINTN) FvHeader->FvLength,
+      NULL,
+      NULL
+      );
+    CurPtr += FvHeader->FvLength;
+  }
+
+  return EFI_SUCCESS;
+}
+
+/**
+  This function will be called when MRC is done.
+
+  @param[in] PeiServices         General purpose services available to every PEIM.
+  @param[in] NotifyDescriptor    Information about the notify event..
+  @param[in] Ppi                 The notify context.
+
+  @retval EFI_SUCCESS            If the function completed successfully.
+**/
+EFI_STATUS
+EFIAPI
+MemoryDiscoveredPpiNotifyCallback (
+  IN EFI_PEI_SERVICES           **PeiServices,
+  IN EFI_PEI_NOTIFY_DESCRIPTOR  *NotifyDescriptor,
+  IN VOID                       *Ppi
+  )
+{
+  UINT64                        LowMemoryLength;
+  UINT64                        HighMemoryLength;
+  UINT64                        MaxLowMemoryLength;
+  UINT8                         PhysicalAddressBits;
+  UINT32                        RegEax;
+  EFI_HOB_RESOURCE_DESCRIPTOR   *Descriptor;
+  VOID                          **HobListPtr;
+
+  DEBUG ((DEBUG_INFO | DEBUG_INIT, "Memory Discovered Notify invoked ...\n"));
+
+  AsmCpuid (0x80000000, &RegEax, NULL, NULL, NULL);
+  if (RegEax >= 0x80000008) {
+    AsmCpuid (0x80000008, &RegEax, NULL, NULL, NULL);
+    PhysicalAddressBits = (UINT8) RegEax;
+  } else {
+    PhysicalAddressBits = 36;
+  }
+
+  //
+  // Create a CPU hand-off information
+  //
+  BuildCpuHob (PhysicalAddressBits, 16);
+
+  //
+  // Get system memory from HOB
+  //
+  FspGetSystemMemorySize (&LowMemoryLength, &HighMemoryLength);
+
+  //
+  // FSP reserved memory is immediately following all available system memory regions,
+  // so we should add it back to ensure this reserved region is cached.
+  //
+  Descriptor =  FspGetResourceDescriptorByOwner (&gFspReservedMemoryResourceHobGuid);
+  ASSERT (Descriptor != NULL);
+  LowMemoryLength =  Descriptor->PhysicalStart + Descriptor->ResourceLength;
+
+  Descriptor =  FspGetResourceDescriptorByOwner (&gFspBootLoaderTolumHobGuid);
+  if (Descriptor) {
+    LowMemoryLength += Descriptor->ResourceLength;
+  }
+
+  DEBUG ((DEBUG_INFO, "FSP TOLM = 0x%08X\n", (UINT32)LowMemoryLength));
+
+  //
+  // Migrate FSP-M UPD data before destroying CAR
+  //
+  MigrateFspmUpdData ();
+
+  HobListPtr = (VOID **)GetFspApiParameter2 ();
+  if (HobListPtr != NULL) {
+    *HobListPtr = (VOID *)GetHobList ();
+  }
+  //
+  // Give control back after MemoryInitApi
+  //
+  FspMemoryInitDone (HobListPtr);
+
+  if (GetFspApiCallingIndex() == TempRamExitApiIndex) {
+    //
+    // Disable CAR
+    //
+    ResetCacheAttributes ();
+
+    //
+    // Set fixed MTRR values
+    //
+    SetCacheAttributes (
+      0x00000,
+      0xA0000,
+      EFI_CACHE_WRITEBACK
+      );
+
+    SetCacheAttributes (
+      0xA0000,
+      0x20000,
+      EFI_CACHE_UNCACHEABLE
+      );
+
+    SetCacheAttributes (
+      0xC0000,
+      0x40000,
+      EFI_CACHE_WRITEPROTECTED
+      );
+
+    //
+    // Set the largest range as WB and then patch smaller ranges with UC
+    // It can reduce the MTRR register usage
+    //
+    MaxLowMemoryLength = GetPowerOfTwo64 (LowMemoryLength);
+    if (LowMemoryLength != MaxLowMemoryLength) {
+      MaxLowMemoryLength = LShiftU64 (MaxLowMemoryLength, 1);
+    }
+    if (MaxLowMemoryLength >= 0x100000000ULL) {
+      MaxLowMemoryLength = (LowMemoryLength + 0x0FFFFFFF) & 0xF0000000;
+    }
+
+    SetCacheAttributes (
+      0,
+      MaxLowMemoryLength,
+      EFI_CACHE_WRITEBACK
+      );
+
+    if (LowMemoryLength != MaxLowMemoryLength) {
+      SetCacheAttributes (
+        LowMemoryLength,
+        MaxLowMemoryLength - LowMemoryLength,
+        EFI_CACHE_UNCACHEABLE
+        );
+    }
+
+    if (HighMemoryLength) {
+      SetCacheAttributes (
+        0x100000000,
+        HighMemoryLength,
+        EFI_CACHE_WRITEBACK
+        );
+    }
+
+    DEBUG ((DEBUG_INFO | DEBUG_INIT, "Memory Discovered Notify completed ...\n"));
+
+    //
+    // Give control back after TempRamExitApi
+    //
+    FspTempRamExitDone ();
+  }
+
+  ReportAndInstallNewFv ();
+
+  return EFI_SUCCESS;
+}
+
+/**
+  Get system low memory size.
+
+  @retval  system memory system below 4GB.
+**/
+UINT32
+GetSystemMemorySizeBelow4Gb (
+  VOID
+  )
+{
+  UINT8 Cmos0x34;
+  UINT8 Cmos0x35;
+
+  //
+  // CMOS 0x34/0x35 specifies the system memory above 16 MB.
+  // * CMOS(0x35) is the high byte
+  // * CMOS(0x34) is the low byte
+  // * The size is specified in 64kb chunks
+  // * Since this is memory above 16MB, the 16MB must be added
+  //   into the calculation to get the total memory size.
+  //
+
+  Cmos0x34 = (UINT8) CmosRead8 (0x34);
+  Cmos0x35 = (UINT8) CmosRead8 (0x35);
+
+  return (UINT32) (((UINTN)((Cmos0x35 << 8) + Cmos0x34) << 16) + SIZE_16MB);
+}
+
+/**
+  Get system high memory size.
+
+  @retval  system memory system above 4GB.
+**/
+UINT64
+GetSystemMemorySizeAbove4Gb (
+  )
+{
+  UINT32 Size;
+  UINTN  CmosIndex;
+
+  //
+  // CMOS 0x5b-0x5d specifies the system memory above 4GB MB.
+  // * CMOS(0x5d) is the most significant size byte
+  // * CMOS(0x5c) is the middle size byte
+  // * CMOS(0x5b) is the least significant size byte
+  // * The size is specified in 64kb chunks
+  //
+
+  Size = 0;
+  for (CmosIndex = 0x5d; CmosIndex >= 0x5b; CmosIndex--) {
+    Size = (UINT32) (Size << 8) + (UINT32) CmosRead8 (CmosIndex);
+  }
+
+  return LShiftU64 (Size, 16);
+}
+
+/**
+  Initialize PCI Express BAR
+
+  @param[in] Did         Host bridge PCI DID.
+
+**/
+VOID
+PciExBarInitialization (
+  IN  UINT16  Did
+  )
+{
+  union {
+    UINT64 Uint64;
+    UINT32 Uint32[2];
+  } PciExBarBase;
+
+  //
+  // We only support the 256MB size for the MMCONFIG area:
+  // 256 buses * 32 devices * 8 functions * 4096 bytes config space.
+  //
+  // The masks used below enforce the Q35 requirements that the MMCONFIG area
+  // be (a) correctly aligned -- here at 256 MB --, (b) located under 64 GB.
+  //
+  // Note that (b) also ensures that the minimum address width we have
+  // determined in AddressWidthInitialization(), i.e., 36 bits, will suffice
+  // for DXE's page tables to cover the MMCONFIG area.
+  //
+  PciExBarBase.Uint64 = PcdGet64 (PcdPciExpressBaseAddress);
+  ASSERT ((PciExBarBase.Uint32[1] & MCH_PCIEXBAR_HIGHMASK) == 0);
+  ASSERT ((PciExBarBase.Uint32[0] & MCH_PCIEXBAR_LOWMASK) == 0);
+  if (Did == INTEL_X58_MCH_DEVICE_ID) {
+    //
+    // Programe PCI MMCFG BAR for X58
+    //
+    PciCf8Write32 (
+      REGISTER_X58_PCIEXBAR,
+      PciExBarBase.Uint32[0] | MCH_PCIEXBAR_EN
+      );
+  } else {
+    //
+    // Clear the PCIEXBAREN bit first, before programming the high register.
+    //
+    PciCf8Write32 (DRAMC_REGISTER_Q35 (MCH_PCIEXBAR_LOW), 0);
+
+    //
+    // Program the high register. Then program the low register, setting the
+    // MMCONFIG area size and enabling decoding at once.
+    //
+    PciCf8Write32 (DRAMC_REGISTER_Q35 (MCH_PCIEXBAR_HIGH), PciExBarBase.Uint32[1]);
+    PciCf8Write32 (
+      DRAMC_REGISTER_Q35 (MCH_PCIEXBAR_LOW),
+      PciExBarBase.Uint32[0] | MCH_PCIEXBAR_BUS_FF | MCH_PCIEXBAR_EN
+      );
+  }
+}
+
+/**
+  Miscellaneous chipset initialization
+
+  @param[in] Did         Host bridge PCI DID.
+
+**/
+VOID
+MiscInitialization (
+  IN  UINT16  Did
+  )
+{
+  UINTN         PmCmd;
+  UINTN         Pmba;
+  UINT32        PmbaAndVal;
+  UINT32        PmbaOrVal;
+  UINTN         AcpiCtlReg;
+  UINT8         AcpiEnBit;
+
+  //
+  // Disable A20 Mask
+  //
+  IoOr8 (0x92, BIT1);
+
+  //
+  // Determine platform type and save Host Bridge DID to PCD
+  //
+  if (Did == INTEL_X58_MCH_DEVICE_ID) {
+    PmCmd      = POWER_MGMT_REGISTER_ICH10 (PCI_COMMAND_OFFSET);
+    Pmba       = POWER_MGMT_REGISTER_ICH10 (ICH10_PMBASE);
+    PmbaAndVal = ~(UINT32)ICH10_PMBASE_MASK;
+    PmbaOrVal  = ICH10_PMBASE_IO;
+    AcpiCtlReg = POWER_MGMT_REGISTER_ICH10 (ICH10_ACPI_CNTL);
+    AcpiEnBit  = ICH10_ACPI_CNTL_ACPI_EN;
+  } else {
+    PmCmd      = POWER_MGMT_REGISTER_Q35 (PCI_COMMAND_OFFSET);
+    Pmba       = POWER_MGMT_REGISTER_Q35 (ICH9_PMBASE);
+    PmbaAndVal = ~(UINT32)ICH9_PMBASE_MASK;
+    PmbaOrVal  = ICH9_PMBASE_VALUE;
+    AcpiCtlReg = POWER_MGMT_REGISTER_Q35 (ICH9_ACPI_CNTL);
+    AcpiEnBit  = ICH9_ACPI_CNTL_ACPI_EN;
+  }
+
+  //
+  // If the appropriate IOspace enable bit is set, assume the ACPI PMBA
+  // has been configured (e.g., by Xen) and skip the setup here.
+  // This matches the logic in AcpiTimerLibConstructor ().
+  //
+  if ((PciRead8 (AcpiCtlReg) & AcpiEnBit) == 0) {
+    //
+    // The PEI phase should be exited with fully accessibe ACPI PM IO space:
+    // 1. set PMBA
+    //
+    PciAndThenOr32 (Pmba, PmbaAndVal, PmbaOrVal);
+
+    //
+    // 2. set PCICMD/IOSE
+    //
+    PciOr8 (PmCmd, EFI_PCI_COMMAND_IO_SPACE);
+
+    //
+    // 3. set ACPI PM IO enable bit (PMREGMISC:PMIOSE or ACPI_CNTL:ACPI_EN)
+    //
+    PciOr8 (AcpiCtlReg, AcpiEnBit);
+  }
+
+  if (Did == INTEL_X58_MCH_DEVICE_ID) {
+    //
+    // Set Root Complex Register Block BAR
+    //
+    PciWrite32 (
+      POWER_MGMT_REGISTER_ICH10 (ICH10_RCBA),
+      ICH10_ROOT_COMPLEX_BASE | ICH10_RCBA_EN
+      );
+
+    //
+    // Enable AHCI and all ports on the SATA controller.
+    //
+    // Address MAP Reg, setting AHCI mode
+    //
+    PciOr16 (PCI_LIB_ADDRESS (0, 31, 2, 0x90), 0x0060);
+    //
+    //Enabling Ports 0-5
+    //
+    PciOr16 (PCI_LIB_ADDRESS (0, 31, 2, 0x92), 0x003F);
+    //
+    //Disabling Sata Controller 2, bit 25 = 1, bit 0 = 1
+    //
+    MmioWrite32(0xFED1F418, 0x02000001);
+    //
+    //Config and enable APIC
+    //
+    MmioWrite8(ICH10_ROOT_COMPLEX_BASE + 0x31FF, 0x01);
+  }
+
+}
+
+/**
+  Platform  chipset initialization
+
+  @param  HostBridgeDevId   The DID for PCI host bridge.
+
+  @retval EFI_UNSUPPORTED        Unsupported chipset.
+  @retval EFI_SUCCESS            Platform has been initialized successfully.
+
+**/
+EFI_STATUS
+PlatformInit (
+  IN UINT16      HostBridgeDevId
+)
+{
+  PciExBarInitialization (HostBridgeDevId);
+
+  MiscInitialization (HostBridgeDevId);
+
+  return EFI_SUCCESS;
+}
+
+/**
+  Initialize TSEG size
+
+  @retval     TSEG size supported by platform.
+
+**/
+UINT32
+InitializeSmramTsegSize (
+  VOID
+  )
+{
+  UINT16        ExtendedTsegMbytes;
+  UINT16        TsegMbytes;
+
+  //
+  // Check if QEMU offers an extended TSEG.
+  //
+  // This can be seen from writing MCH_EXT_TSEG_MB_QUERY to the MCH_EXT_TSEG_MB
+  // register, and reading back the register.
+  //
+  // On a QEMU machine type that does not offer an extended TSEG, the initial
+  // write overwrites whatever value a malicious guest OS may have placed in
+  // the (unimplemented) register, before entering S3 or rebooting.
+  // Subsequently, the read returns MCH_EXT_TSEG_MB_QUERY unchanged.
+  //
+  // On a QEMU machine type that offers an extended TSEG, the initial write
+  // triggers an update to the register. Subsequently, the value read back
+  // (which is guaranteed to differ from MCH_EXT_TSEG_MB_QUERY) tells us the
+  // number of megabytes.
+  //
+  PciWrite16 (DRAMC_REGISTER_Q35 (MCH_EXT_TSEG_MB), MCH_EXT_TSEG_MB_QUERY);
+  ExtendedTsegMbytes = PciRead16 (DRAMC_REGISTER_Q35 (MCH_EXT_TSEG_MB));
+  if (ExtendedTsegMbytes == MCH_EXT_TSEG_MB_QUERY) {
+    TsegMbytes = 0x10;
+    PciWrite16 (DRAMC_REGISTER_Q35 (MCH_EXT_TSEG_MB), TsegMbytes);
+  } else {
+    TsegMbytes = ExtendedTsegMbytes;
+  }
+
+  return (UINT32)TsegMbytes << 20;
+}
+
+
+/**
+  FSP Init before memory PEI module entry point
+
+  @param[in]  FileHandle           Not used.
+  @param[in]  PeiServices          General purpose services available to every PEIM.
+
+  @retval     EFI_SUCCESS          The function completes successfully
+  @retval     EFI_OUT_OF_RESOURCES Insufficient resources to create database
+**/
+EFI_STATUS
+EFIAPI
+FspmInitEntryPoint (
+  IN       EFI_PEI_FILE_HANDLE  FileHandle,
+  IN CONST EFI_PEI_SERVICES     **PeiServices
+  )
+{
+  EFI_STATUS                      Status;
+  UINT64                          PeiMemSize;
+  EFI_PHYSICAL_ADDRESS            PeiMemBase;
+  FSPM_UPD                       *FspmUpd;
+  EFI_BOOT_MODE                   BootMode;
+  UINT32                          LowMemLen;
+  UINT64                          HighMemLen;
+  UINT32                          TsegSize;
+  UINT32                          TsegBase;
+  UINT8                           EsmramcVal;
+  UINT8                           Q35TsegMbytes;
+  UINT32                          TopOfLowRam;
+  UINT32                          TopOfLowRamMb;
+  UINT16                          HostBridgeDevId;
+
+  DEBUG ((DEBUG_INFO, "FspmInitPoint() - Begin\n"));
+
+
+
+  //
+  // Query Host Bridge DID
+  //
+  HostBridgeDevId = PciCf8Read16 (OVMF_HOSTBRIDGE_DID);
+  if ((HostBridgeDevId != INTEL_Q35_MCH_DEVICE_ID) && (HostBridgeDevId != INTEL_X58_MCH_DEVICE_ID)) {
+    DEBUG ((DEBUG_ERROR, "Unknown Host Bridge Device ID: 0x%04x\n", HostBridgeDevId));
+    ASSERT (FALSE);
+    return EFI_UNSUPPORTED;
+  }
+
+  //
+  // QEMU init
+  //
+  Status = PlatformInit (HostBridgeDevId);
+
+  //
+  // Get the Boot Mode
+  //
+  FspmUpd  = (FSPM_UPD *)GetFspMemoryInitUpdDataPointer ();
+  BootMode = FspmUpd->FspmArchUpd.BootMode;
+  DEBUG ((DEBUG_INFO, "BootMode : 0x%x\n", BootMode));
+  PeiServicesSetBootMode (BootMode);
+
+
+  Status = PeiServicesInstallPpi (&mPpiBootMode);
+
+  //
+  // Now that all of the pre-permanent memory activities have
+  // been taken care of, post a call-back for the permanent-memory
+  // resident services, such as HOB construction.
+  // PEI Core will switch stack after this PEIM exit.  After that the MTRR
+  // can be set.
+  //
+  Status = PeiServicesNotifyPpi (&mMemoryDiscoveredNotifyList);
+  ASSERT_EFI_ERROR (Status);
+
+  LowMemLen  = GetSystemMemorySizeBelow4Gb();
+  HighMemLen = GetSystemMemorySizeAbove4Gb();
+  if (HostBridgeDevId == INTEL_X58_MCH_DEVICE_ID) {
+    TsegSize = SIZE_8MB;
+  } else {
+    TsegSize = InitializeSmramTsegSize ();
+  }
+  TsegBase   = LowMemLen - TsegSize;
+
+  //
+  // Confirm if QEMU supports SMRAM.
+  //
+  // With no support for it, the ESMRAMC (Extended System Management RAM
+  // Control) register reads as zero. If there is support, the cache-enable
+  // bits are hard-coded as 1 by QEMU.
+  //
+  EsmramcVal = PciRead8 (DRAMC_REGISTER_Q35 (MCH_ESMRAMC));
+
+  TopOfLowRam = LowMemLen;
+  ASSERT ((TopOfLowRam & (SIZE_1MB - 1)) == 0);
+  TopOfLowRamMb = TopOfLowRam >> 20;
+
+  //
+  // Some of the following registers are no-ops for QEMU at the moment, but it
+  // is recommended to set them correctly, since the ESMRAMC that we ultimately
+  // care about is in the same set of registers.
+  //
+  // First, we disable the integrated VGA, and set both the GTT Graphics Memory
+  // Size and the Graphics Mode Select memory pre-allocation fields to zero.
+  // This takes just one write to the Graphics Control Register.
+  //
+  PciWrite16 (DRAMC_REGISTER_Q35 (MCH_GGC), MCH_GGC_IVD);
+
+  //
+  // Set Top of Low Usable DRAM.
+  //
+  PciWrite16 (DRAMC_REGISTER_Q35 (MCH_TOLUD),
+    (UINT16)(TopOfLowRamMb << MCH_TOLUD_MB_SHIFT));
+
+  //
+  // Given the zero graphics memory sizes configured above, set the
+  // graphics-related stolen memory bases to the same as TOLUD.
+  //
+  PciWrite32 (DRAMC_REGISTER_Q35 (MCH_GBSM),
+    TopOfLowRamMb << MCH_GBSM_MB_SHIFT);
+  PciWrite32 (DRAMC_REGISTER_Q35 (MCH_BGSM),
+    TopOfLowRamMb << MCH_BGSM_MB_SHIFT);
+
+  //
+  // Set TSEG Memory Base.
+  //
+  PciWrite32 (DRAMC_REGISTER_Q35 (MCH_TSEGMB),
+    (TopOfLowRamMb << MCH_TSEGMB_MB_SHIFT) - TsegSize);
+
+  Q35TsegMbytes = (UINT8)(TsegSize >> MCH_TSEGMB_MB_SHIFT);
+
+  //
+  // Set TSEG size, and disable TSEG visibility outside of SMM. Note that the
+  // T_EN bit has inverse meaning; when T_EN is set, then TSEG visibility is
+  // *restricted* to SMM.
+  //
+  EsmramcVal &= ~(UINT32)MCH_ESMRAMC_TSEG_MASK;
+  EsmramcVal |= Q35TsegMbytes == 8 ? MCH_ESMRAMC_TSEG_8MB :
+                Q35TsegMbytes == 2 ? MCH_ESMRAMC_TSEG_2MB :
+                Q35TsegMbytes == 1 ? MCH_ESMRAMC_TSEG_1MB :
+                MCH_ESMRAMC_TSEG_EXT;
+  EsmramcVal |= MCH_ESMRAMC_T_EN;
+  PciWrite8 (DRAMC_REGISTER_Q35 (MCH_ESMRAMC), EsmramcVal);
+
+  //
+  // TSEG should be closed (see above), but unlocked, initially. Set G_SMRAME
+  // (Global SMRAM Enable) too, as both D_LCK and T_EN depend on it.
+  //
+  PciAndThenOr8 (DRAMC_REGISTER_Q35 (MCH_SMRAM),
+    (UINT8)((~(UINT32)MCH_SMRAM_D_LCK) & 0xff), MCH_SMRAM_G_SMRAME);
+
+  PeiMemSize = PcdGet32(PcdFspReservedMemoryLength);
+  ASSERT (LowMemLen > PeiMemSize + TsegSize);
+  PeiMemBase = LowMemLen - TsegSize - PeiMemSize;
+
+  //
+  // Report first 640KB of memory
+  //
+  BuildResourceDescriptorHob (
+    EFI_RESOURCE_SYSTEM_MEMORY,
+    MEM_TESTED_ATTR,
+    (EFI_PHYSICAL_ADDRESS) (0),
+    (UINT64) (0xA0000)
+  );
+
+  //
+  // Report first 0A0000h - 0FFFFFh as RESERVED memory
+  //
+  BuildResourceDescriptorHob (
+    EFI_RESOURCE_MEMORY_RESERVED,
+    MEM_TESTED_ATTR,
+    (EFI_PHYSICAL_ADDRESS) (0xA0000),
+    (UINT64) (0x60000)
+  );
+
+  //
+  // Report first 0x100000 - FSP reserved memory as system memory
+  //
+  BuildResourceDescriptorHob (
+    EFI_RESOURCE_SYSTEM_MEMORY,
+    MEM_TESTED_ATTR,
+    (EFI_PHYSICAL_ADDRESS) (0x100000),
+    (UINT64) (PeiMemBase - 0x100000)
+  );
+
+  BuildResourceDescriptorWithOwnerHob (
+     EFI_RESOURCE_MEMORY_RESERVED,
+     (
+       EFI_RESOURCE_ATTRIBUTE_PRESENT |
+       EFI_RESOURCE_ATTRIBUTE_INITIALIZED |
+       EFI_RESOURCE_ATTRIBUTE_TESTED |
+       EFI_RESOURCE_ATTRIBUTE_UNCACHEABLE |
+       EFI_RESOURCE_ATTRIBUTE_WRITE_COMBINEABLE |
+       EFI_RESOURCE_ATTRIBUTE_WRITE_THROUGH_CACHEABLE |
+       EFI_RESOURCE_ATTRIBUTE_WRITE_BACK_CACHEABLE
+     ),
+     PeiMemBase,
+     PeiMemSize,
+     &gFspReservedMemoryResourceHobGuid
+   );
+
+  if (HighMemLen) {
+    BuildResourceDescriptorHob (
+     EFI_RESOURCE_SYSTEM_MEMORY,
+     MEM_NOT_TESTED_ATTR,
+     0x100000000ULL,
+     HighMemLen
+    );
+  }
+
+  // Report TSEG memroy
+  BuildResourceDescriptorWithOwnerHob (
+      EFI_RESOURCE_MEMORY_RESERVED,
+      (
+        EFI_RESOURCE_ATTRIBUTE_PRESENT |
+        EFI_RESOURCE_ATTRIBUTE_INITIALIZED |
+        EFI_RESOURCE_ATTRIBUTE_TESTED |
+        EFI_RESOURCE_ATTRIBUTE_UNCACHEABLE |
+        EFI_RESOURCE_ATTRIBUTE_WRITE_COMBINEABLE |
+        EFI_RESOURCE_ATTRIBUTE_WRITE_THROUGH_CACHEABLE |
+        EFI_RESOURCE_ATTRIBUTE_WRITE_BACK_CACHEABLE
+      ),
+      TsegBase,
+      TsegSize,
+      &gFspReservedMemoryResourceHobTsegGuid
+    );
+
+  Status = PeiServicesInstallPeiMemory (PeiMemBase, PeiMemSize);
+
+  DEBUG ((DEBUG_INFO, "FspmInitPoint() - End\n"));
+
+  return Status;
+}
diff --git a/QemuFspPkg/FspmInit/FspmInit.h b/QemuFspPkg/FspmInit/FspmInit.h
new file mode 100644
index 0000000000..7d69a0ddb1
--- /dev/null
+++ b/QemuFspPkg/FspmInit/FspmInit.h
@@ -0,0 +1,77 @@
+/** @file
+  FSP-M implementation related header file.
+
+  Copyright (c) 2017 - 2018, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php.
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#ifndef _FSPM_INIT_H_
+#define _FSPM_INIT_H_
+
+#include <Library/PeiServicesLib.h>
+#include <Library/BaseMemoryLib.h>
+#include <Library/IoLib.h>
+#include <Library/HobLib.h>
+#include <Library/PcdLib.h>
+#include <Library/DebugLib.h>
+#include <Library/MemoryAllocationLib.h>
+#include <Library/PciLib.h>
+#include <Library/PciCf8Lib.h>
+#include <Library/FspSwitchStackLib.h>
+#include <Library/FspCommonLib.h>
+#include <Library/FspPlatformLib.h>
+#include <Library/CacheLib.h>
+#include <Ppi/MemoryDiscovered.h>
+#include <Ppi/TemporaryRamSupport.h>
+#include <Ppi/MasterBootMode.h>
+#include <Guid/FspHeaderFile.h>
+#include <FspmUpd.h>
+#include "OvmfPlatforms.h"
+
+//
+// MRC Variable Attributes
+//
+#define MEM_TESTED_ATTR \
+          (EFI_RESOURCE_ATTRIBUTE_PRESENT                 | \
+           EFI_RESOURCE_ATTRIBUTE_INITIALIZED             | \
+           EFI_RESOURCE_ATTRIBUTE_TESTED                  | \
+           EFI_RESOURCE_ATTRIBUTE_UNCACHEABLE             | \
+           EFI_RESOURCE_ATTRIBUTE_WRITE_COMBINEABLE       | \
+           EFI_RESOURCE_ATTRIBUTE_WRITE_THROUGH_CACHEABLE | \
+           EFI_RESOURCE_ATTRIBUTE_WRITE_BACK_CACHEABLE)
+
+#define MEM_NOT_TESTED_ATTR \
+          (EFI_RESOURCE_ATTRIBUTE_PRESENT                 | \
+           EFI_RESOURCE_ATTRIBUTE_INITIALIZED             | \
+           EFI_RESOURCE_ATTRIBUTE_UNCACHEABLE             | \
+           EFI_RESOURCE_ATTRIBUTE_WRITE_COMBINEABLE       | \
+           EFI_RESOURCE_ATTRIBUTE_WRITE_THROUGH_CACHEABLE | \
+           EFI_RESOURCE_ATTRIBUTE_WRITE_BACK_CACHEABLE)
+
+/**
+  This function will be called when MRC is done.
+
+  @param  PeiServices General purpose services available to every PEIM.
+
+  @param  NotifyDescriptor Information about the notify event..
+
+  @param  Ppi The notify context.
+
+  @retval EFI_SUCCESS If the function completed successfully.
+**/
+EFI_STATUS
+EFIAPI
+MemoryDiscoveredPpiNotifyCallback (
+  IN EFI_PEI_SERVICES          **PeiServices,
+  IN EFI_PEI_NOTIFY_DESCRIPTOR *NotifyDescriptor,
+  IN VOID                      *Ppi
+  );
+
+#endif
diff --git a/QemuFspPkg/FspmInit/FspmInit.inf b/QemuFspPkg/FspmInit/FspmInit.inf
new file mode 100644
index 0000000000..fce0bc4ea7
--- /dev/null
+++ b/QemuFspPkg/FspmInit/FspmInit.inf
@@ -0,0 +1,67 @@
+## @file
+#   FSP-M component implementation.
+#
+#  Copyright (c) 2017 - 2018, Intel Corporation. All rights reserved.<BR>
+#
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution. The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php.
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+#
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = FspmInit
+  FILE_GUID                      = 9E1CC850-6731-4848-8752-6673C7005EEE
+  MODULE_TYPE                    = PEIM
+  VERSION_STRING                 = 1.0
+  ENTRY_POINT                    = FspmInitEntryPoint
+
+[Sources]
+  FspmInit.h
+  FspmInit.c
+
+[Packages]
+  MdePkg/MdePkg.dec
+  MdeModulePkg/MdeModulePkg.dec
+  IntelFsp2Pkg/IntelFsp2Pkg.dec
+  QemuFspPkg/QemuFspPkg.dec
+
+[Ppis]
+  gEfiPeiResetPpiGuid                       ## PRODUCES
+  gEfiPeiMemoryDiscoveredPpiGuid            ## NOTIFY
+  gEfiPeiMasterBootModePpiGuid              ## PRODUCES
+  gEfiTemporaryRamSupportPpiGuid
+
+[Guids]
+  gFspReservedMemoryResourceHobGuid         ## CONSUMES
+  gFspBootLoaderTolumHobGuid                ## CONSUMES
+  gFspReservedMemoryResourceHobTsegGuid     ## CONSUMES
+
+[Protocols]
+  gEfiPciEnumerationCompleteProtocolGuid    ## CONSUMES
+
+[Pcd]
+  gEfiMdePkgTokenSpaceGuid.PcdPciExpressBaseAddress
+  gIntelFsp2PkgTokenSpaceGuid.PcdTemporaryRamBase
+  gIntelFsp2PkgTokenSpaceGuid.PcdTemporaryRamSize
+  gIntelFsp2PkgTokenSpaceGuid.PcdFspReservedBufferSize
+  gIntelFsp2PkgTokenSpaceGuid.PcdFspReservedMemoryLength
+  gIntelFsp2PkgTokenSpaceGuid.PcdFspAreaSize
+
+[LibraryClasses]
+  #
+  # Generic library class
+  #
+  PeimEntryPoint
+  FspPlatformLib
+  FspCommonLib
+  CacheLib
+  PciCf8Lib
+  PciLib
+
+[Depex]
+  TRUE
diff --git a/QemuFspPkg/FspsInit/FspsInit.c b/QemuFspPkg/FspsInit/FspsInit.c
new file mode 100644
index 0000000000..cd1024fea7
--- /dev/null
+++ b/QemuFspPkg/FspsInit/FspsInit.c
@@ -0,0 +1,234 @@
+/** @file
+  FSP-S component implementation.
+
+  Copyright (c) 2017 - 2018, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php.
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include "FspsInit.h"
+
+static EFI_PEI_NOTIFY_DESCRIPTOR  mNotifyList[] = {
+  {
+    EFI_PEI_PPI_DESCRIPTOR_NOTIFY_CALLBACK,
+    &gEfiEndOfPeiSignalPpiGuid,
+    FspInitEndOfPeiCallback
+  },
+  {
+    EFI_PEI_PPI_DESCRIPTOR_NOTIFY_CALLBACK,
+    &gFspEventEndOfFirmwareGuid,
+    FspEndOfFirmwareCallback
+  },
+  {
+    EFI_PEI_PPI_DESCRIPTOR_NOTIFY_CALLBACK,
+    &gEfiEventReadyToBootGuid,
+    FspReadyToBootCallback
+  },
+  {
+    EFI_PEI_PPI_DESCRIPTOR_NOTIFY_CALLBACK,
+    &gEfiPeiGraphicsPpiGuid,
+    FspGfxInitCallback
+  },
+  {
+    EFI_PEI_PPI_DESCRIPTOR_NOTIFY_CALLBACK | EFI_PEI_PPI_DESCRIPTOR_TERMINATE_LIST,
+    &gEfiPciEnumerationCompleteProtocolGuid,
+    FspInitAfterPciEnumerationCallback
+  }
+};
+
+
+/**
+  FSP graphics initialization after PCI enumeration
+
+  @param[in]  PeiServices        Pointer to PEI Services Table.
+  @param[in]  NotifyDescriptor   Pointer to the descriptor for the Notification event that
+                                 caused this function to execute.
+  @param[in]  Ppi                Pointer to the PPI data associated with this function.
+
+  @retval     EFI_SUCCESS        The function completes successfully
+
+**/
+EFI_STATUS
+EFIAPI
+FspGfxInitCallback (
+  IN  EFI_PEI_SERVICES            **PeiServices,
+  IN  EFI_PEI_NOTIFY_DESCRIPTOR   *NotifyDescriptor,
+  IN  VOID                        *Ppi
+  )
+{
+  EFI_STATUS                   Status;
+  EFI_PEI_GRAPHICS_PPI        *GfxInitPpi;
+  FSPS_UPD                    *FspsUpd;
+
+  GfxInitPpi = (EFI_PEI_GRAPHICS_PPI *)Ppi;
+
+  FspsUpd = GetFspSiliconInitUpdDataPointer ();
+
+  ///
+  /// Call PeiGraphicsPpi.GraphicsPpiInit to initilize the display
+  ///
+  DEBUG ((DEBUG_INFO, "GraphicsPpiInit Start\n"));
+  Status = GfxInitPpi->GraphicsPpiInit ((VOID *)FspsUpd->FspsConfig.GraphicsConfigPtr);
+  if (EFI_ERROR (Status)) {
+    DEBUG ((DEBUG_ERROR, "GraphicsPpiInit failed. \n"));
+  }
+
+  return Status;
+}
+
+/**
+  FSP initialization at the end of PEI
+
+  @param[in]  PeiServices        Pointer to PEI Services Table.
+  @param[in]  NotifyDescriptor   Pointer to the descriptor for the Notification event that
+                                 caused this function to execute.
+  @param[in]  Ppi                Pointer to the PPI data associated with this function.
+
+  @retval     EFI_SUCCESS        The function completes successfully
+
+**/
+EFI_STATUS
+EFIAPI
+FspInitEndOfPeiCallback (
+  IN  EFI_PEI_SERVICES            **PeiServices,
+  IN  EFI_PEI_NOTIFY_DESCRIPTOR   *NotifyDescriptor,
+  IN  VOID                        *Ppi
+  )
+{
+  // Place holder
+  DEBUG ((DEBUG_INFO, "FspInitEndOfPeiCallback++\n"));
+
+  DEBUG ((DEBUG_INFO, "FspInitEndOfPeiCallback--\n"));
+
+  return EFI_SUCCESS;
+}
+
+/**
+  FSP initialization after PCI enumeration
+
+  @param[in]  PeiServices        Pointer to PEI Services Table.
+  @param[in]  NotifyDescriptor   Pointer to the descriptor for the Notification event that
+                                 caused this function to execute.
+  @param[in]  Ppi                Pointer to the PPI data associated with this function.
+
+  @retval     EFI_SUCCESS        The function completes successfully
+
+**/
+EFI_STATUS
+EFIAPI
+FspInitAfterPciEnumerationCallback (
+  IN  EFI_PEI_SERVICES            **PeiServices,
+  IN  EFI_PEI_NOTIFY_DESCRIPTOR   *NotifyDescriptor,
+  IN  VOID                        *Ppi
+  )
+{
+  // Place holder
+  DEBUG ((DEBUG_INFO, "FspInitAfterPciEnumerationCallback++\n"));
+
+  DEBUG ((DEBUG_INFO, "FspInitAfterPciEnumerationCallback--\n"));
+
+  return EFI_SUCCESS;
+}
+
+/**
+  FSP initialization at ready to boot event
+
+  @param[in]  PeiServices        Pointer to PEI Services Table.
+  @param[in]  NotifyDescriptor   Pointer to the descriptor for the Notification event that
+                                 caused this function to execute.
+  @param[in]  Ppi                Pointer to the PPI data associated with this function.
+
+  @retval     EFI_SUCCESS        The function completes successfully
+
+**/
+EFI_STATUS
+EFIAPI
+FspReadyToBootCallback (
+  IN  EFI_PEI_SERVICES            **PeiServices,
+  IN  EFI_PEI_NOTIFY_DESCRIPTOR   *NotifyDescriptor,
+  IN  VOID                        *Ppi
+  )
+{
+  // Place holder
+  DEBUG ((DEBUG_INFO, "FspReadyToBootCallback++\n"));
+
+  DEBUG ((DEBUG_INFO, "FspReadyToBootCallback--\n"));
+
+  return EFI_SUCCESS;
+}
+
+/**
+  FSP initialization at the end of firmware
+
+  @param[in]  PeiServices        Pointer to PEI Services Table.
+  @param[in]  NotifyDescriptor   Pointer to the descriptor for the Notification event that
+                                 caused this function to execute.
+  @param[in]  Ppi                Pointer to the PPI data associated with this function.
+
+  @retval     EFI_SUCCESS        The function completes successfully
+
+**/
+EFI_STATUS
+EFIAPI
+FspEndOfFirmwareCallback (
+  IN  EFI_PEI_SERVICES            **PeiServices,
+  IN  EFI_PEI_NOTIFY_DESCRIPTOR   *NotifyDescriptor,
+  IN  VOID                        *Ppi
+  )
+{
+  // Place holder
+  DEBUG ((DEBUG_INFO, "FspEndOfFirmwareCallback++\n"));
+
+  DEBUG ((DEBUG_INFO, "FspEndOfFirmwareCallback--\n"));
+
+  return EFI_SUCCESS;
+}
+
+/**
+  FSP Init before memory PEI module entry point
+
+  @param[in]  FileHandle           Not used.
+  @param[in]  PeiServices          General purpose services available to every PEIM.
+
+  @retval     EFI_SUCCESS          The function completes successfully
+  @retval     EFI_OUT_OF_RESOURCES Insufficient resources to create database
+**/
+EFI_STATUS
+EFIAPI
+FspsInitEntryPoint (
+  IN       EFI_PEI_FILE_HANDLE  FileHandle,
+  IN CONST EFI_PEI_SERVICES     **PeiServices
+  )
+{
+  EFI_STATUS                   Status;
+  FSPS_UPD                    *FspsUpd;
+  FSP_INFO_HEADER             *FspInfoHeader;
+
+  Status = EFI_SUCCESS;
+  FspsUpd = NULL;
+
+  DEBUG ((DEBUG_INFO, "FspInitEntryPoint() - start\n"));
+  FspInfoHeader = GetFspInfoHeaderFromApiContext ();
+  SetFspInfoHeader (FspInfoHeader);
+
+  FspsUpd = (FSPS_UPD *)GetFspApiParameter();
+  if (FspsUpd == NULL) {
+    //
+    // Use the UpdRegion as default
+    //
+    FspsUpd = (FSPS_UPD *) (FspInfoHeader->ImageBase + FspInfoHeader->CfgRegionOffset);
+  }
+  SetFspSiliconInitUpdDataPointer (FspsUpd);
+
+  Status = PeiServicesNotifyPpi (&mNotifyList[0]);
+  ASSERT_EFI_ERROR (Status);
+
+  DEBUG ((DEBUG_INFO, "FspInitEntryPoint() - end\n"));
+  return Status;
+}
diff --git a/QemuFspPkg/FspsInit/FspsInit.h b/QemuFspPkg/FspsInit/FspsInit.h
new file mode 100644
index 0000000000..5c5e2801b1
--- /dev/null
+++ b/QemuFspPkg/FspsInit/FspsInit.h
@@ -0,0 +1,124 @@
+/** @file
+  FSP-S implementation related header file.
+
+  Copyright (c) 2017 - 2018, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php.
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#ifndef _FSP_INIT_PEI_H_
+#define _FSP_INIT_PEI_H_
+
+#include <Library/PeiServicesLib.h>
+#include <Library/DebugLib.h>
+#include <Library/HobLib.h>
+#include <Library/MemoryAllocationLib.h>
+#include <Library/FspCommonLib.h>
+#include <Protocol/PciEnumerationComplete.h>
+#include <Ppi/EndOfPeiPhase.h>
+#include <Ppi/Graphics.h>
+#include <FspmUpd.h>
+#include <FspsUpd.h>
+
+/**
+  FSP initialization after PCI enumeration
+
+  @param[in]  PeiServices        Pointer to PEI Services Table.
+  @param[in]  NotifyDescriptor   Pointer to the descriptor for the Notification event that
+                                 caused this function to execute.
+  @param[in]  Ppi                Pointer to the PPI data associated with this function.
+
+  @retval     EFI_SUCCESS        The function completes successfully
+
+**/
+EFI_STATUS
+EFIAPI
+FspInitAfterPciEnumerationCallback (
+  IN  EFI_PEI_SERVICES            **PeiServices,
+  IN  EFI_PEI_NOTIFY_DESCRIPTOR   *NotifyDescriptor,
+  IN  VOID                        *Ppi
+  );
+
+/**
+  FSP initialization at the end of PEI
+
+  @param[in]  PeiServices        Pointer to PEI Services Table.
+  @param[in]  NotifyDescriptor   Pointer to the descriptor for the Notification event that
+                                 caused this function to execute.
+  @param[in]  Ppi                Pointer to the PPI data associated with this function.
+
+  @retval     EFI_SUCCESS        The function completes successfully
+
+**/
+EFI_STATUS
+EFIAPI
+FspInitEndOfPeiCallback (
+  IN  EFI_PEI_SERVICES            **PeiServices,
+  IN  EFI_PEI_NOTIFY_DESCRIPTOR   *NotifyDescriptor,
+  IN  VOID                        *Ppi
+  );
+
+/**
+  FSP initialization at ready to boot event
+
+  @param[in]  PeiServices        Pointer to PEI Services Table.
+  @param[in]  NotifyDescriptor   Pointer to the descriptor for the Notification event that
+                                 caused this function to execute.
+  @param[in]  Ppi                Pointer to the PPI data associated with this function.
+
+  @retval     EFI_SUCCESS        The function completes successfully
+
+**/
+EFI_STATUS
+EFIAPI
+FspReadyToBootCallback (
+  IN  EFI_PEI_SERVICES            **PeiServices,
+  IN  EFI_PEI_NOTIFY_DESCRIPTOR   *NotifyDescriptor,
+  IN  VOID                        *Ppi
+  );
+
+/**
+  FSP initialization at the end of firmware
+
+  @param[in]  PeiServices        Pointer to PEI Services Table.
+  @param[in]  NotifyDescriptor   Pointer to the descriptor for the Notification event that
+                                 caused this function to execute.
+  @param[in]  Ppi                Pointer to the PPI data associated with this function.
+
+  @retval     EFI_SUCCESS        The function completes successfully
+
+**/
+EFI_STATUS
+EFIAPI
+FspEndOfFirmwareCallback (
+  IN  EFI_PEI_SERVICES            **PeiServices,
+  IN  EFI_PEI_NOTIFY_DESCRIPTOR   *NotifyDescriptor,
+  IN  VOID                        *Ppi
+  );
+
+/**
+  FSP graphics initialization after PCI enumeration
+
+  @param[in]  PeiServices        Pointer to PEI Services Table.
+  @param[in]  NotifyDescriptor   Pointer to the descriptor for the Notification event that
+                                 caused this function to execute.
+  @param[in]  Ppi                Pointer to the PPI data associated with this function.
+
+  @retval     EFI_SUCCESS        The function completes successfully
+
+**/
+EFI_STATUS
+EFIAPI
+FspGfxInitCallback (
+  IN  EFI_PEI_SERVICES            **PeiServices,
+  IN  EFI_PEI_NOTIFY_DESCRIPTOR   *NotifyDescriptor,
+  IN  VOID                        *Ppi
+  );
+
+#endif
diff --git a/QemuFspPkg/FspsInit/FspsInit.inf b/QemuFspPkg/FspsInit/FspsInit.inf
new file mode 100644
index 0000000000..3744dd2e53
--- /dev/null
+++ b/QemuFspPkg/FspsInit/FspsInit.inf
@@ -0,0 +1,55 @@
+## @file
+#   FSP-S component implementation.
+#
+#  Copyright (c) 2017 - 2018, Intel Corporation. All rights reserved.<BR>
+#
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution. The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php.
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+#
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = FspsInit
+  FILE_GUID                      = 131B73AC-C033-4DE1-8794-6DAB08E731CF
+  MODULE_TYPE                    = PEIM
+  VERSION_STRING                 = 1.0
+  ENTRY_POINT                    = FspsInitEntryPoint
+
+[Sources]
+  FspsInit.h
+  FspsInit.c
+
+[Packages]
+  MdePkg/MdePkg.dec
+  IntelFsp2Pkg/IntelFsp2Pkg.dec
+  QemuFspPkg/QemuFspPkg.dec
+
+[Ppis]
+  gEfiEndOfPeiSignalPpiGuid                 ## CONSUMES
+  gEfiPeiStallPpiGuid                       ## CONSUMES
+  gEfiPeiGraphicsPpiGuid                    ## CONSUMES
+
+[Protocols]
+  gEfiPciEnumerationCompleteProtocolGuid    ## CONSUMES
+
+[Guids]
+  gEfiEventReadyToBootGuid                  ## CONSUMES ## Event
+  gFspEventEndOfFirmwareGuid                ## CONSUMES ## Event
+  gFspNonVolatileStorageHobGuid             ## CONSUMES
+
+[LibraryClasses]
+  #
+  # Generic library class
+  #
+  PeimEntryPoint
+  FspCommonLib
+
+[Pcd]
+
+[Depex]
+  TRUE
diff --git a/QemuFspPkg/Include/BootLoaderPlatformData.h b/QemuFspPkg/Include/BootLoaderPlatformData.h
new file mode 100644
index 0000000000..4ee96bbf49
--- /dev/null
+++ b/QemuFspPkg/Include/BootLoaderPlatformData.h
@@ -0,0 +1,33 @@
+/** @file
+  FSP platform specific data structure to be included.
+
+  Copyright (c) 2017 - 2018, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php.
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#ifndef _BL_PLATFORM_DATA_H
+#define _BL_PLATFORM_DATA_H
+
+//
+// @note
+// All lines between tag EXTERNAL_BOOTLOADER_STRUCT_BEGIN and
+// EXTERNAL_BOOTLOADER_STRUCT_END will be exported to the generated
+// FspUpdVpd.h file by the tool.
+//
+
+#pragma pack(1)
+
+/* !EXPORT FSPM EXTERNAL_BOOTLOADER_STRUCT_BEGIN */
+
+/* !EXPORT FSPM EXTERNAL_BOOTLOADER_STRUCT_END   */
+
+#pragma pack()
+
+#endif
diff --git a/QemuFspPkg/Include/ChipsetAccess.h b/QemuFspPkg/Include/ChipsetAccess.h
new file mode 100644
index 0000000000..7a27644eca
--- /dev/null
+++ b/QemuFspPkg/Include/ChipsetAccess.h
@@ -0,0 +1,23 @@
+/** @file
+  QEMU silicon register access related header file.
+
+  Copyright (c) 2017 - 2018, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php.
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#ifndef _CHIPSET_ACCESS_H_
+#define _CHIPSET_ACCESS_H_
+
+#include "ScAccess.h"
+#include "SaRegs.h"
+#include "SaAccess.h"
+#include "SaCommonDefinitions.h"
+
+#endif
diff --git a/QemuFspPkg/Include/FspUpd.h b/QemuFspPkg/Include/FspUpd.h
new file mode 100644
index 0000000000..0845cf600c
--- /dev/null
+++ b/QemuFspPkg/Include/FspUpd.h
@@ -0,0 +1,48 @@
+/** @file
+
+Copyright (c) 2018, Intel Corporation. All rights reserved.<BR>
+
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+* Redistributions of source code must retain the above copyright notice, this
+  list of conditions and the following disclaimer.
+* Redistributions in binary form must reproduce the above copyright notice, this
+  list of conditions and the following disclaimer in the documentation and/or
+  other materials provided with the distribution.
+* Neither the name of Intel Corporation nor the names of its contributors may
+  be used to endorse or promote products derived from this software without
+  specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  This file is automatically generated. Please do NOT modify !!!
+
+**/
+
+#ifndef __FSPUPD_H__
+#define __FSPUPD_H__
+
+#include <FspEas.h>
+
+#pragma pack(1)
+
+#define FSPT_UPD_SIGNATURE               0x545F4450554D4551        /* 'QEMUPD_T' */
+
+#define FSPM_UPD_SIGNATURE               0x4D5F4450554D4551        /* 'QEMUPD_M' */
+
+#define FSPS_UPD_SIGNATURE               0x535F4450554D4551        /* 'QEMUPD_S' */
+
+#pragma pack()
+
+#endif
diff --git a/QemuFspPkg/Include/FspmUpd.h b/QemuFspPkg/Include/FspmUpd.h
new file mode 100644
index 0000000000..5931bfdc23
--- /dev/null
+++ b/QemuFspPkg/Include/FspmUpd.h
@@ -0,0 +1,108 @@
+/** @file
+
+Copyright (c) 2018, Intel Corporation. All rights reserved.<BR>
+
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+* Redistributions of source code must retain the above copyright notice, this
+  list of conditions and the following disclaimer.
+* Redistributions in binary form must reproduce the above copyright notice, this
+  list of conditions and the following disclaimer in the documentation and/or
+  other materials provided with the distribution.
+* Neither the name of Intel Corporation nor the names of its contributors may
+  be used to endorse or promote products derived from this software without
+  specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  This file is automatically generated. Please do NOT modify !!!
+
+**/
+
+#ifndef __FSPMUPD_H__
+#define __FSPMUPD_H__
+
+#include <FspUpd.h>
+
+#pragma pack(1)
+
+
+
+/** Fsp M Configuration
+**/
+typedef struct {
+
+/** Offset 0x0040 - Debug Serial Port Base address
+  Debug serial port base address. This option will be used only when the 'Serial Port
+  Debug Device' option is set to 'External Device'. 0x00000000(Default).
+**/
+  UINT32                      SerialDebugPortAddress;
+
+/** Offset 0x0044 - Debug Serial Port Type
+  16550 compatible debug serial port resource type. NONE means no serial port support.
+  0x02:MMIO(Default).
+  0:NONE, 1:I/O, 2:MMIO
+**/
+  UINT8                       SerialDebugPortType;
+
+/** Offset 0x0045 - Serial Port Debug Device
+  Select active serial port device for debug. For SOC UART devices,'Debug Serial Port
+  Base' options will be ignored. 0x02:SOC UART2(Default).
+  0:SOC UART0, 1:SOC UART1, 2:SOC UART2, 3:External Device
+**/
+  UINT8                       SerialDebugPortDevice;
+
+/** Offset 0x0046 - Debug Serial Port Stride Size
+  Debug serial port register map stride size in bytes. 0x00:1, 0x02:4(Default).
+  0:1, 2:4
+**/
+  UINT8                       SerialDebugPortStrideSize;
+
+/** Offset 0x0047
+**/
+  UINT8                       UnusedUpdSpace0[49];
+
+/** Offset 0x0078
+**/
+  UINT8                       ReservedFspmUpd[4];
+} FSP_M_CONFIG;
+
+/** Fsp M UPD Configuration
+**/
+typedef struct {
+
+/** Offset 0x0000
+**/
+  FSP_UPD_HEADER              FspUpdHeader;
+
+/** Offset 0x0020
+**/
+  FSPM_ARCH_UPD               FspmArchUpd;
+
+/** Offset 0x0040
+**/
+  FSP_M_CONFIG                FspmConfig;
+
+/** Offset 0x007C
+**/
+  UINT8                       UnusedUpdSpace1[2];
+
+/** Offset 0x007E
+**/
+  UINT16                      UpdTerminator;
+} FSPM_UPD;
+
+#pragma pack()
+
+#endif
diff --git a/QemuFspPkg/Include/FspsUpd.h b/QemuFspPkg/Include/FspsUpd.h
new file mode 100644
index 0000000000..a109552c9f
--- /dev/null
+++ b/QemuFspPkg/Include/FspsUpd.h
@@ -0,0 +1,101 @@
+/** @file
+
+Copyright (c) 2018, Intel Corporation. All rights reserved.<BR>
+
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+* Redistributions of source code must retain the above copyright notice, this
+  list of conditions and the following disclaimer.
+* Redistributions in binary form must reproduce the above copyright notice, this
+  list of conditions and the following disclaimer in the documentation and/or
+  other materials provided with the distribution.
+* Neither the name of Intel Corporation nor the names of its contributors may
+  be used to endorse or promote products derived from this software without
+  specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  This file is automatically generated. Please do NOT modify !!!
+
+**/
+
+#ifndef __FSPSUPD_H__
+#define __FSPSUPD_H__
+
+#include <FspUpd.h>
+
+#pragma pack(1)
+
+
+/** Fsp S Configuration
+**/
+typedef struct {
+
+/** Offset 0x0040 - BMP Logo Data Size
+  BMP logo data buffer size. 0x00000000(Default).
+**/
+  UINT32                      LogoSize;
+
+/** Offset 0x0044 - BMP Logo Data Pointer
+  BMP logo data pointer to a BMP format buffer. 0x00000000(Default).
+**/
+  UINT32                      LogoPtr;
+
+/** Offset 0x0048 - Graphics Configuration Data Pointer
+  Graphics configuration data used for initialization. 0x00000000(Default).
+**/
+  UINT32                      GraphicsConfigPtr;
+
+/** Offset 0x004C - PCI Temporary MMIO Base
+  PCI Temporary MMIO Base used before full PCI enumeration. 0x80000000(Default).
+**/
+  UINT32                      PciTempResourceBase;
+
+/** Offset 0x0050
+**/
+  UINT8                       UnusedUpdSpace1[32];
+
+/** Offset 0x0070
+**/
+  UINT8                       ReservedFspsUpd;
+} FSP_S_CONFIG;
+
+/** Fsp S UPD Configuration
+**/
+typedef struct {
+
+/** Offset 0x0000
+**/
+  FSP_UPD_HEADER              FspUpdHeader;
+
+/** Offset 0x0020
+**/
+  UINT8                       UnusedUpdSpace0[32];
+
+/** Offset 0x0040
+**/
+  FSP_S_CONFIG                FspsConfig;
+
+/** Offset 0x0071
+**/
+  UINT8                       UnusedUpdSpace2[13];
+
+/** Offset 0x007E
+**/
+  UINT16                      UpdTerminator;
+} FSPS_UPD;
+
+#pragma pack()
+
+#endif
diff --git a/QemuFspPkg/Include/FsptUpd.h b/QemuFspPkg/Include/FsptUpd.h
new file mode 100644
index 0000000000..4340184d3f
--- /dev/null
+++ b/QemuFspPkg/Include/FsptUpd.h
@@ -0,0 +1,101 @@
+/** @file
+
+Copyright (c) 2018, Intel Corporation. All rights reserved.<BR>
+
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+* Redistributions of source code must retain the above copyright notice, this
+  list of conditions and the following disclaimer.
+* Redistributions in binary form must reproduce the above copyright notice, this
+  list of conditions and the following disclaimer in the documentation and/or
+  other materials provided with the distribution.
+* Neither the name of Intel Corporation nor the names of its contributors may
+  be used to endorse or promote products derived from this software without
+  specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  This file is automatically generated. Please do NOT modify !!!
+
+**/
+
+#ifndef __FSPTUPD_H__
+#define __FSPTUPD_H__
+
+#include <FspUpd.h>
+
+#pragma pack(1)
+
+
+/** Fsp T Common UPD
+**/
+typedef struct {
+
+/** Offset 0x0020
+**/
+  UINT8                       Revision;
+
+/** Offset 0x0021
+**/
+  UINT8                       Reserved[3];
+
+/** Offset 0x0024
+**/
+  UINT32                      MicrocodeRegionBase;
+
+/** Offset 0x0028
+**/
+  UINT32                      MicrocodeRegionLength;
+
+/** Offset 0x002C
+**/
+  UINT32                      CodeRegionBase;
+
+/** Offset 0x0030
+**/
+  UINT32                      CodeRegionLength;
+
+/** Offset 0x0034
+**/
+  UINT8                       Reserved1[12];
+} FSPT_COMMON_UPD;
+
+/** Fsp T UPD Configuration
+**/
+typedef struct {
+
+/** Offset 0x0000
+**/
+  FSP_UPD_HEADER              FspUpdHeader;
+
+/** Offset 0x0020
+**/
+  FSPT_COMMON_UPD             FsptCommonUpd;
+
+/** Offset 0x0040
+**/
+  UINT8                       ReservedFsptUpd1[32];
+
+/** Offset 0x0060
+**/
+  UINT8                       UnusedUpdSpace0[48];
+
+/** Offset 0x0090
+**/
+  UINT16                      UpdTerminator;
+} FSPT_UPD;
+
+#pragma pack()
+
+#endif
diff --git a/QemuFspPkg/Include/OvmfPlatforms.h b/QemuFspPkg/Include/OvmfPlatforms.h
new file mode 100644
index 0000000000..251a22b2f2
--- /dev/null
+++ b/QemuFspPkg/Include/OvmfPlatforms.h
@@ -0,0 +1,45 @@
+/** @file
+  OVMF Platform definitions
+
+  Copyright (C) 2015, Red Hat, Inc.
+  Copyright (c) 2014, Gabriel L. Somlo <somlo@cmu.edu>
+
+  This program and the accompanying materials are licensed and made
+  available under the terms and conditions of the BSD License which
+  accompanies this distribution.   The full text of the license may
+  be found at http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+**/
+
+#ifndef __OVMF_PLATFORMS_H__
+#define __OVMF_PLATFORMS_H__
+
+#include <Library/PciLib.h>
+#include <IndustryStandard/Pci22.h>
+#include <Q35MchIch9.h>
+#include <X58Ich10.h>
+
+//
+// OVMF Host Bridge DID Address
+//
+#define OVMF_HOSTBRIDGE_DID \
+  PCI_LIB_ADDRESS (0, 0, 0, PCI_DEVICE_ID_OFFSET)
+
+//
+// Values we program into the PM base address registers
+//
+#define ICH9_PMBASE_VALUE 0x0400
+
+//
+// Common bits in same-purpose registers
+//
+#define PMBA_RTE BIT0
+
+//
+// Common IO ports relative to the Power Management Base Address
+//
+#define ACPI_TIMER_OFFSET 0x8
+
+#endif
diff --git a/QemuFspPkg/Include/Q35MchIch9.h b/QemuFspPkg/Include/Q35MchIch9.h
new file mode 100644
index 0000000000..f559740fee
--- /dev/null
+++ b/QemuFspPkg/Include/Q35MchIch9.h
@@ -0,0 +1,113 @@
+/** @file
+  Various register numbers and value bits based on the following publications:
+  - Intel(R) datasheet 316966-002
+  - Intel(R) datasheet 316972-004
+
+  Copyright (C) 2015, Red Hat, Inc.
+  Copyright (c) 2014, Gabriel L. Somlo <somlo@cmu.edu>
+
+  This program and the accompanying materials are licensed and made available
+  under the terms and conditions of the BSD License which accompanies this
+  distribution.   The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS, WITHOUT
+  WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+**/
+
+#ifndef __Q35_MCH_ICH9_H__
+#define __Q35_MCH_ICH9_H__
+
+#include <Library/PciLib.h>
+
+//
+// Host Bridge Device ID (DID) value for Q35/MCH
+//
+#define INTEL_Q35_MCH_DEVICE_ID 0x29C0
+
+//
+// B/D/F/Type: 0/0/0/PCI
+//
+#define DRAMC_REGISTER_Q35(Offset) PCI_LIB_ADDRESS (0, 0, 0, (Offset))
+
+#define MCH_EXT_TSEG_MB       0x50
+#define MCH_EXT_TSEG_MB_QUERY   0xFFFF
+
+#define MCH_GGC               0x52
+#define MCH_GGC_IVD             BIT1
+
+#define MCH_PCIEXBAR_LOW      0x60
+#define MCH_PCIEXBAR_LOWMASK    0x0FFFFFFF
+#define MCH_PCIEXBAR_BUS_FF     0
+#define MCH_PCIEXBAR_EN         BIT0
+
+#define MCH_PCIEXBAR_HIGH     0x64
+#define MCH_PCIEXBAR_HIGHMASK   0xFFFFFFF0
+
+#define MCH_SMRAM             0x9D
+#define MCH_SMRAM_D_LCK         BIT4
+#define MCH_SMRAM_G_SMRAME      BIT3
+
+#define MCH_ESMRAMC           0x9E
+#define MCH_ESMRAMC_H_SMRAME    BIT7
+#define MCH_ESMRAMC_E_SMERR     BIT6
+#define MCH_ESMRAMC_SM_CACHE    BIT5
+#define MCH_ESMRAMC_SM_L1       BIT4
+#define MCH_ESMRAMC_SM_L2       BIT3
+#define MCH_ESMRAMC_TSEG_8MB    BIT2
+#define MCH_ESMRAMC_TSEG_2MB    BIT1
+#define MCH_ESMRAMC_TSEG_1MB    0
+#define MCH_ESMRAMC_TSEG_MASK   (BIT2 | BIT1)
+#define MCH_ESMRAMC_TSEG_EXT    MCH_ESMRAMC_TSEG_MASK
+#define MCH_ESMRAMC_T_EN        BIT0
+
+#define MCH_GBSM              0xA4
+#define MCH_GBSM_MB_SHIFT       20
+
+#define MCH_BGSM              0xA8
+#define MCH_BGSM_MB_SHIFT       20
+
+#define MCH_TSEGMB            0xAC
+#define MCH_TSEGMB_MB_SHIFT     20
+
+#define MCH_TOLUD             0xB0
+#define MCH_TOLUD_MB_SHIFT      4
+
+//
+// B/D/F/Type: 0/0x1f/0/PCI
+//
+#define POWER_MGMT_REGISTER_Q35(Offset) \
+  PCI_LIB_ADDRESS (0, 0x1f, 0, (Offset))
+
+#define POWER_MGMT_REGISTER_Q35_EFI_PCI_ADDRESS(Offset) \
+  EFI_PCI_ADDRESS (0, 0x1f, 0, (Offset))
+
+#define ICH9_PMBASE               0x40
+#define ICH9_PMBASE_MASK            (BIT15 | BIT14 | BIT13 | BIT12 | BIT11 | \
+                                     BIT10 | BIT9  | BIT8  | BIT7)
+
+#define ICH9_ACPI_CNTL            0x44
+#define ICH9_ACPI_CNTL_ACPI_EN      BIT7
+
+#define ICH9_GEN_PMCON_1          0xA0
+#define ICH9_GEN_PMCON_1_SMI_LOCK   BIT4
+
+#define ICH9_RCBA                 0xF0
+#define ICH9_RCBA_EN                BIT0
+
+//
+// IO ports
+//
+#define ICH9_APM_CNT 0xB2
+#define ICH9_APM_STS 0xB3
+
+//
+// IO ports relative to PMBASE
+//
+#define ICH9_PMBASE_OFS_SMI_EN 0x30
+#define ICH9_SMI_EN_APMC_EN      BIT5
+#define ICH9_SMI_EN_GBL_SMI_EN   BIT0
+
+#define ICH9_ROOT_COMPLEX_BASE 0xFED1C000
+
+#endif
diff --git a/QemuFspPkg/Include/X58Ich10.h b/QemuFspPkg/Include/X58Ich10.h
new file mode 100644
index 0000000000..9de5b8bd72
--- /dev/null
+++ b/QemuFspPkg/Include/X58Ich10.h
@@ -0,0 +1,51 @@
+/** @file
+  Various register numbers and value bits based on the following publications:
+  - Intel(R) datasheet 316966-002
+  - Intel(R) datasheet 316972-004
+
+  Copyright (C) 2015, Red Hat, Inc.
+  Copyright (c) 2014, Gabriel L. Somlo <somlo@cmu.edu>
+
+  This program and the accompanying materials are licensed and made available
+  under the terms and conditions of the BSD License which accompanies this
+  distribution.   The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS, WITHOUT
+  WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+**/
+
+#ifndef __X58_ICH10_H__
+#define __X58_ICH10_H__
+
+//
+// Host Bridge Device ID (DID) value for Q35/MCH
+//
+#define INTEL_X58_MCH_DEVICE_ID 0x3400
+
+#define REGISTER_X58_PCIEXBAR  PCI_CF8_LIB_ADDRESS (0xFF, 0, 1, 0x50)
+
+//
+// B/D/F/Type: 0/0x1f/0/PCI
+//
+#define POWER_MGMT_REGISTER_ICH10(Offset) \
+  PCI_LIB_ADDRESS (0, 0x1f, 0, (Offset))
+
+#define ICH10_PMBASE               0x40
+#define ICH10_PMBASE_MASK            (BIT15 | BIT14 | BIT13 | BIT12 | BIT11 | \
+                                     BIT10 | BIT9  | BIT8  | BIT7)
+
+#define ICH10_ACPI_CNTL            0x44
+#define ICH10_ACPI_CNTL_ACPI_EN      BIT7
+
+#define ICH10_GEN_PMCON_1          0xA0
+#define ICH10_GEN_PMCON_1_SMI_LOCK   BIT4
+
+#define ICH10_RCBA                 0xF0
+#define ICH10_RCBA_EN                BIT0
+
+#define ICH10_PMBASE_IO            0x400
+
+#define ICH10_ROOT_COMPLEX_BASE    0xFED1C000
+
+#endif
diff --git a/QemuFspPkg/Library/PlatformSecLib/Ia32/Chipset.inc b/QemuFspPkg/Library/PlatformSecLib/Ia32/Chipset.inc
new file mode 100644
index 0000000000..a9b6e03024
--- /dev/null
+++ b/QemuFspPkg/Library/PlatformSecLib/Ia32/Chipset.inc
@@ -0,0 +1,121 @@
+;; @file
+; Chipset constants and macros
+;
+; Copyright (c) 2017-2018 Intel Corporation.
+;
+; This program and the accompanying materials
+; are licensed and made available under the terms and conditions of the BSD License
+; which accompanies this distribution.  The full text of the license may be found at
+; http://opensource.org/licenses/bsd-license.php
+;
+; THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+; WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+;
+;------------------------------------------------------------------------------
+;;
+
+;
+; APIC register
+;
+APICID                        EQU 0FEE00020h
+
+;
+; base addresses and register definitions.
+;
+
+B_ACPI_BASE_EN      EQU BIT1
+  R_ACPI_PM1_CNT          EQU 004h
+  V_ACPI_PM1_CNT_S5       EQU 01C00h
+  R_ACPI_PM1_TMR          EQU 008h
+  R_TCO_STS               EQU 064h
+  B_TCO_STS_SECOND_TO     EQU BIT17
+  R_TCO_CNT               EQU 068h
+  B_TCO_CNT_TMR_HLT       EQU BIT11
+
+  B_SMBUS_PCICMD_IOSE     EQU BIT0
+  R_SMBUS_AUXC            EQU 00Dh
+
+ACPI_BASE_ADDRESS         EQU 0400h
+SPI_BASE_ADDRESS          EQU 0FED01000h
+;  B_LPC_SPI_BASE_EN       EQU BIT1
+  R_SPI_BCR               EQU 0DCh
+  R_PMC_GEN_PMCON_1       EQU 01020h
+  R_PMC_PMIR              EQU 01048h
+  B_PMC_PMIR_CF9GR        EQU BIT20
+
+  B_LPC_PUNIT_BASE_EN     EQU BIT1
+
+  B_LPC_ILB_BASE_EN       EQU BIT1
+
+  B_LPC_RCBA_EN           EQU BIT0
+
+  B_LPC_IO_BASE_EN        EQU BIT1
+
+  B_LPC_MPHY_BASE_EN      EQU BIT1
+
+PCH_RCBA_BASE_ADDRESS     EQU 0FED1C000h
+
+MCH_BASE_ADDRESS              EQU 0FED10000h
+  B_MCH_BASE_ADDRESS_EN       EQU BIT0
+
+;
+;B_Unit Registers
+;
+BUNIT_BMISC                   EQU 6800h
+  B_BMISC_RESDRAM             EQU 01h   ;Bit 0 - When this bit is set, reads targeting E-segment are routed to DRAM.
+  B_BMISC_RFSDRAM             EQU 02h   ;Bit 1 - When this bit is set, reads targeting F-segment are routed to DRAM.
+
+;
+; HPET compare register
+;
+HPET_COMP_1                   EQU 0FED00108h
+HPET_COMP_2                   EQU 0FED0010Ch
+HPET_COMP_3                   EQU 0FED00128h
+HPET_COMP_4                   EQU 0FED00148h
+HPTC_AE                       EQU BIT7
+;
+; MCH PCIe base address
+;
+CPU_HEC_SIZE                  EQU 000000000h      ; 256M
+CPU_HEC_EN                    EQU 000000001h      ; Enable
+CPU0_HEC_PCI_ADDR             EQU 080FF0150h
+CPU1_HEC_PCI_ADDR             EQU 080FE0150h
+CPU_HEC_BASE                  EQU 0E0000000h
+
+;
+; PCI registers
+;
+R_MCH_BASE                EQU (( 0h * 8 + 00h) * 1000h + 0048h)
+R_LPC_ACPI_BASE           EQU ((1Fh * 8 + 00h) * 1000h + 0040h)
+R_LPC_PMC_BASE            EQU ((1Fh * 8 + 00h) * 1000h + 0044h)
+R_LPC_IO_BASE             EQU ((1Fh * 8 + 00h) * 1000h + 004Ch)
+R_LPC_ILB_BASE            EQU ((1Fh * 8 + 00h) * 1000h + 0050h)
+R_LPC_SPI_BASE            EQU ((1Fh * 8 + 00h) * 1000h + 0054h)
+R_LPC_MPHY_BASE           EQU ((1Fh * 8 + 00h) * 1000h + 0058h)
+R_LPC_PUNIT_BASE          EQU ((1Fh * 8 + 00h) * 1000h + 005Ch)
+R_LPC_RCBA                EQU ((1Fh * 8 + 00h) * 1000h + 00F0h)
+R_SMBUS_CMD               EQU ((1Fh * 8 + 03h) * 1000h + 0004h)
+R_SMBUS_BASE              EQU ((1Fh * 8 + 03h) * 1000h + 0020h)
+R_P2SB_PCI_CMD            EQU ((0Dh * 8 + 00h) * 1000h + 0004h)
+R_P2SB_MMIO_BAR0          EQU ((0Dh * 8 + 00h) * 1000h + 0010h)
+R_P2SB_HPTC               EQU ((0Dh * 8 + 00h) * 1000h + 0060h)  ;HPTC config register. B0:D13:F0 0x60x
+R_PMC_PCI_CMD             EQU ((0Dh * 8 + 01h) * 1000h + 0004h)
+R_PMC_ACPI_BASE           EQU ((0Dh * 8 + 01h) * 1000h + 0020h)  ;BAR2 IO config register. B0:D13:F1 0x20
+R_PMC_MMIO_BAR0           EQU ((0Dh * 8 + 01h) * 1000h + 0010h)  ;BAR0 IO config register. B0:D13:F1 0x10
+R_PMC_MMIO_BAR1           EQU ((0Dh * 8 + 01h) * 1000h + 0018h)  ;BAR1 IO config register. B0:D13:F1 0x18
+
+SYRE_CPURST                   EQU 14
+
+;
+; PCIEXBAR constants for enable in bit [0]
+;
+ENABLE                        EQU 1
+
+;
+; PCIEXBAR constants for size in bit [2:1]
+;
+PCIEXBAR_64MB                 EQU 010b
+PCIEXBAR_128MB                EQU 001b
+PCIEXBAR_256MB                EQU 000b
+
+MMCFG_BASE                    EQU CPU_HEC_BASE    ; 4GB-128MB
diff --git a/QemuFspPkg/Library/PlatformSecLib/Ia32/Ia32Nasm.inc b/QemuFspPkg/Library/PlatformSecLib/Ia32/Ia32Nasm.inc
new file mode 100644
index 0000000000..c50997e54b
--- /dev/null
+++ b/QemuFspPkg/Library/PlatformSecLib/Ia32/Ia32Nasm.inc
@@ -0,0 +1,169 @@
+;; @file
+; IA32 architecture MSRs
+;
+; Copyright (c) 2017-2018 Intel Corporation.
+;
+; This program and the accompanying materials
+; are licensed and made available under the terms and conditions of the BSD License
+; which accompanies this distribution.  The full text of the license may be found at
+; http://opensource.org/licenses/bsd-license.php
+;
+; THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+; WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+;
+;------------------------------------------------------------------------------
+;;
+
+;
+; WSM CPUID vs. stepping
+;
+%define WSM_A0_STEPPING 0x206C0
+%define IA32_MTRR_CAP 0xFE
+%define MTRR_PHYS_BASE_0 0x200
+%define MTRR_PHYS_MASK_0 0x201
+%define MTRR_PHYS_BASE_1 0x202
+%define MTRR_PHYS_MASK_1 0x203
+%define MTRR_PHYS_BASE_2 0x204
+%define MTRR_PHYS_MASK_2 0x205
+%define MTRR_PHYS_BASE_3 0x206
+%define MTRR_PHYS_MASK_3 0x207
+%define MTRR_PHYS_BASE_4 0x208
+%define MTRR_PHYS_MASK_4 0x209
+%define MTRR_PHYS_BASE_5 0x20A
+%define MTRR_PHYS_MASK_5 0x20B
+%define MTRR_PHYS_BASE_6 0x20C
+%define MTRR_PHYS_MASK_6 0x20D
+%define MTRR_PHYS_BASE_7 0x20E
+%define MTRR_PHYS_MASK_7 0x20F
+%define MTRR_PHYS_BASE_8 0x210
+%define MTRR_PHYS_MASK_8 0x211
+%define MTRR_PHYS_BASE_9 0x212
+%define MTRR_PHYS_MASK_9 0x213
+%define MTRR_FIX_64K_00000 0x250
+%define MTRR_FIX_16K_80000 0x258
+%define MTRR_FIX_16K_A0000 0x259
+%define MTRR_FIX_4K_C0000 0x268
+%define MTRR_FIX_4K_C8000 0x269
+%define MTRR_FIX_4K_D0000 0x26A
+%define MTRR_FIX_4K_D8000 0x26B
+%define MTRR_FIX_4K_E0000 0x26C
+%define MTRR_FIX_4K_E8000 0x26D
+%define MTRR_FIX_4K_F0000 0x26E
+%define MTRR_FIX_4K_F8000 0x26F
+%define MTRR_DEF_TYPE 0x2FF
+
+%define MTRR_MEMORY_TYPE_UC 0x0
+%define MTRR_MEMORY_TYPE_WC 0x1
+%define MTRR_MEMORY_TYPE_WT 0x4
+%define MTRR_MEMORY_TYPE_WP 0x5
+%define MTRR_MEMORY_TYPE_WB 0x6
+
+%define MTRR_DEF_TYPE_E 0x800
+%define MTRR_DEF_TYPE_FE 0x400
+%define MTRR_PHYSMASK_VALID 0x800
+
+;
+; Define the high 32 bits of MTRR masking
+; This should be read from CPUID EAX = 080000008h, EAX bits [7:0]
+; But for most platforms this will be a fixed supported size so it is
+; fixed to save space.
+;
+%define MTRR_PHYS_MASK_VALID 0x800
+%define MTRR_PHYS_MASK_HIGH 0xF      ; For 36 bit addressing
+;MTRR_PHYS_MASK_HIGH           EQU 0000000FFh      ; For 40 bit addressing
+
+%define IA32_MISC_ENABLE 0x1A0
+%define FAST_STRING_ENABLE_BIT 0x1
+
+%define CR0_CACHE_DISABLE 0x40000000
+%define CR0_NO_WRITE 0x20000000
+
+%define IA32_PLATFORM_ID 0x17
+%define IA32_BIOS_UPDT_TRIG 0x79
+%define IA32_BIOS_SIGN_ID 0x8B
+%define PLATFORM_INFO 0xCE
+%define NO_EVICT_MODE 0x2E0
+%define NO_EVICTION_ENABLE_BIT 0x1
+
+;
+; MSR definitions
+;
+%define MSR_IA32_PLATFORM_ID 0x17
+%define MSR_APIC_BASE 0x1B
+%define MSR_SOCKET_ID 0x39
+%define MSR_IA32_FEATURE_CONTROL 0x3A
+%define MSR_CLOCK_CST_CONFIG_CONTROL 0xE2
+%define MSR_CLOCK_FLEX_MAX 0x194
+%define MSR_IA32_PERF_STS 0x198
+%define MSR_IA32_PERF_CTL 0x199
+%define MSR_IA32_MISC_ENABLES 0x1A0
+%define MSR_IA32_MC8_MISC2 0x288
+%define MSR_IA32_MC7_CTL 0x41C
+
+;
+; CSR definitions
+;
+%define CSR_DESIRED_CORES 0x80            ; D0:F0:R80h
+%define CSR_DESIRED_CORES_LOCK_BIT 16
+%define CSR_DESIRED_CORES_SMT_BIT 8
+%define CSR_DESIRED_CORES_COUNT_MASK 7
+%define CSR_DESIRED_SMT_CORE_COUNT_MASK 0x107
+
+%define CSR_DESIRED_CORES_HT_DISABLED_BIT 0xFFFFF100
+%define CSR_DESIRED_CORES_MC_DISABLED_BIT 0xFFFC
+%define CSR_DESIRED_CORES_HT_DISABLED 0x100
+%define CSR_DESIRED_CORES_MC_DISABLED 0x1
+
+%define CSR_SVID_SDID 0x2C            ; D0:F0:R2Ch
+%define DEAFULT_SVID_SDID 0x80868086       ; DWORD Access & Write Once ONLY
+
+;
+; Processor MSR definitions
+;
+%define MSR_BBL_CR_CTL3 0x11E ; L2 cache configuration MSR
+%define B_MSR_BBL_CR_CTL3_L2_NOT_PRESENT 23    ; L2 not present
+%define B_MSR_BBL_CR_CTL3_L2_ENABLED 8    ; L2 enabled
+%define B_MSR_BBL_CR_CTL3_L2_HARDWARE_ENABLED 0    ; L2 hardware enabled
+
+%define P6RatioBitsMask 0x1F  ; Bitmask for cpu ratio
+%define P6_FREQ_LOCKED_BIT 15d
+
+;
+; Local APIC Register Equates
+;
+%define LOCAL_APIC_ID_REG 0xFEE00020
+%define APIC_ICR_HI 0xFEE00310
+%define APIC_ICR_LO 0xFEE00300
+%define ANDICRMask 0xFFF32000      ; AND mask for ICR Saving reserved bits
+%define ORSelfINIT 0x4500      ; OR mask to send INIT IPI to itself
+%define ORAllButSelf 0xC0000      ; OR mask to set dest field = "All But Self"
+
+;
+; Cache control macro
+;
+%macro DISABLE_CACHE 0
+    mov   eax, cr0
+    or    eax, CR0_CACHE_DISABLE + CR0_NO_WRITE
+    wbinvd
+    mov   cr0, eax
+%endmacro
+
+%macro ENABLE_CACHE 0
+    mov   eax, cr0
+    and   eax, ~ (CR0_CACHE_DISABLE + CR0_NO_WRITE)
+    wbinvd
+    mov   cr0, eax
+%endmacro
+
+%define VENDOR_ID_REG 0
+%define PCI_REVISION_ID_REG 8
+%define CPU_GENERIC_UNCORE_DEV 0
+%define CPU_GENERIC_UNCORE_FUNC 0
+%define CPU_LINK_1_DEV 2
+%define CPU_LINK_1_FUNC 4
+
+%define B0_CPU_STEPPING 0x10
+
+%define BLOCK_LENGTH_BYTES 2048
+
+
diff --git a/QemuFspPkg/Library/PlatformSecLib/Ia32/PlatformNasm.inc b/QemuFspPkg/Library/PlatformSecLib/Ia32/PlatformNasm.inc
new file mode 100644
index 0000000000..58acba976d
--- /dev/null
+++ b/QemuFspPkg/Library/PlatformSecLib/Ia32/PlatformNasm.inc
@@ -0,0 +1,143 @@
+;; @file
+; Provide macro for QEMU CAR initialization
+;
+; Copyright (c) 2017-2018 Intel Corporation.
+;
+; This program and the accompanying materials
+; are licensed and made available under the terms and conditions of the BSD License
+; which accompanies this distribution.  The full text of the license may be found at
+; http://opensource.org/licenses/bsd-license.php
+;
+; THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+; WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+;
+;------------------------------------------------------------------------------
+;;
+
+
+;INCLUDE FlashMap.inc ;ECP porting
+
+MKF_SOFTSDV_FLAG              EQU   0
+
+; Set "MINIMUM_BOOT_SUPPORT" flag allows BIOS boot as minimum feature in SEC phase.
+MINIMUM_BOOT_SUPPORT          EQU 0               ; ="0", Normal Boot;
+                                                  ; ="1", Minimum Feature Boot
+; "RESET_IN_SEC" flag allows BIOS doing RESET in SEC phase
+RESET_IN_SEC                  EQU 0               ; ="0", RESET occurs in OemIohInit.c
+                                                  ; ="1", RESET occurs in SEC phase
+
+EARLY_MICROCODE_SUPPORT       EQU 1
+DETERMINISTIC_BSP_SUPPORT     EQU 0
+DEBUG                         EQU 1
+
+;
+; IO port to access the upper 128-byte of RTC RAM
+;
+RTC_UPPER_INDEX               EQU 072h
+RTC_UPPER_DATA                EQU 073h
+
+;
+; Offset of data stored in the upper 128-byte of RTC RAM.
+;
+CMOS_CPU_BSP_SELECT           EQU 010h            ; BspSelection
+CMOS_CPU_UP_MODE              EQU 011h            ; UpBootSelection
+
+;
+; Cpu Ratio and Vid stored in the upper 128-byte of RTC RAM.
+;
+CMOS_CPU_RATIO_OFFSET         EQU 012h            ; ProcessorFlexibleRatio
+CMOS_CPU_CORE_HT_OFFSET       EQU 013h            ; ProcessorHyperThreadingEnable & EnableCoresInSbsp & EnableCoresInNbsp
+
+;
+; CPU Feature
+;
+CMOS_CPU_BIST_OFFSET          EQU 015h            ; ProcessorBistEnable
+CMOS_CPU_VMX_OFFSET           EQU 016h            ; ProcessorVmxEnable
+
+;
+; Port80 Selection
+;
+CMOS_PORT80_OFFSET            EQU 017h            ; Port80Route
+
+;
+;Flash layout map
+;
+;PEICODE_REGION_BASE_ADDRESS   EQU ASM_PFX(FLASH_BASE)
+;PEICODE_REGION_SIZE           EQU ASM_PFX(FLASH_SIZE)
+;PEICODE_REGION_SIZE_MASK      EQU (~ (PEICODE_REGION_SIZE - 1))
+
+BIOS_REGION_UPDATABLE_STATUS  EQU 0058h            ; Offset
+;----------------------------------------------------------------------------------------
+; "Merlin" support used equates
+;----------------------------------------------------------------------------------------
+MAGIC_ADDRESS_IN_SEG          EQU  0FFF0h
+MAGIC_SEG                     EQU  0F000h
+
+;
+; -- Equates for CAR initialization
+;    TileSize (must be a power of 2)
+;
+; Define the tile size
+; The tile size and tile placement are critical to ensuring that no data loss occurs
+; See BWG - chapter "Determining Tile Size"
+;
+TILE_SIZE                     EQU 000000000h
+
+;
+; See BWG - chapter "Determining Cacheable Code Region Base Addresses and Ranges".
+;
+; Now FvRecovery base address and size is determined by PcdFlashFvIBBMBase and PcdFlashFvIBBMSize.
+;
+
+WDB_REGION_BASE_ADDRESS             EQU 040000000h
+WDB_REGION_SIZE                     EQU 01000h
+WDB_REGION_SIZE_MASK                EQU (~ (WDB_REGION_SIZE - 1))
+
+;
+; See BWG - chapter "Determining Data Stack Base Address and Range"
+;
+; Now Data Stack base address and size is determined by PcdTemporaryRamBase and PcdTemporaryRamSize.
+;
+
+;
+; Cache init and test values
+; These are inverted to flip each bit at least once
+;
+CACHE_INIT_VALUE              EQU 0A5A5A5A5h
+
+;ECP porting
+;CACHE_TEST_VALUE             EQU (NOT CACHE_INIT_VALUE)
+CACHE_TEST_VALUE              EQU 05aa55aa5h
+
+PEI_CORE_ENTRY_BASE           EQU 0FFFFFFE0h
+FV_MAIN_BASE                  EQU 0FFFFFFFCh
+
+MAX_NR_BUS                    EQU 0FFh
+MAX_NR_CPU_SOCKETS            EQU 2               ; DP example, MP may have 4 or more
+
+BIT0                          EQU 01h
+BIT1                          EQU 02h
+BIT2                          EQU 04h
+BIT3                          EQU 08h
+BIT4                          EQU 10h
+BIT5                          EQU 20h
+BIT6                          EQU 40h
+BIT7                          EQU 80h
+BIT8                          EQU 100h
+BIT9                          EQU 200h
+BIT10                         EQU 400h
+BIT11                         EQU 800h
+BIT12                         EQU 1000h
+BIT13                         EQU 2000h
+BIT14                         EQU 4000h
+BIT15                         EQU 8000h
+BIT16                         EQU 10000h
+BIT17                         EQU 20000h
+BIT18                         EQU 40000h
+BIT19                         EQU 80000h
+BIT20                         EQU 0100000h
+BIT23                         EQU 0800000h
+BIT31                         EQU 080000000h
+; Bit definition in MM1
+;BadCMOSDetected               EQU (BIT0 shl 17)
+BSPApicIDSaveStart            EQU 24
diff --git a/QemuFspPkg/Library/PlatformSecLib/Ia32/SecCoreNasm.inc b/QemuFspPkg/Library/PlatformSecLib/Ia32/SecCoreNasm.inc
new file mode 100644
index 0000000000..5651e377e6
--- /dev/null
+++ b/QemuFspPkg/Library/PlatformSecLib/Ia32/SecCoreNasm.inc
@@ -0,0 +1,61 @@
+;; @file
+; Provide macro for QEMU CAR initialization
+;
+; Copyright (c) 2017-2018 Intel Corporation.
+;
+; This program and the accompanying materials
+; are licensed and made available under the terms and conditions of the BSD License
+; which accompanies this distribution.  The full text of the license may be found at
+; http://opensource.org/licenses/bsd-license.php
+;
+; THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+; WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+;
+;------------------------------------------------------------------------------
+;;
+
+;
+; Set to 1 to enable debug
+;
+NO_EVICTION_MODE_DEBUG  EQU     1
+
+;
+;args 1: Status
+;
+%macro STATUS_CODE 1
+%if NO_EVICTION_MODE_DEBUG
+                    mov  al, %1
+                    out  080h, al
+%endif
+%endmacro
+
+%macro STATUS_CODE2 1
+                    mov  al, %1
+                    out  080h, al
+%endmacro
+
+FVHEADER_LEN_OFF    EQU 30h
+FFSHEADER_LEN       EQU 18h
+
+IMAGE_BASE_ADDRESS  EQU 0FFFF0000h
+
+;
+; Set to 1 to enable debug support for "Deterministic BSP selection"
+;
+AP_ENTRY_DELAY      EQU         10h
+AP_EXECUTION_DELAY  EQU         1000h
+
+;
+; Define the segment used for AP start-up
+; It should be on the top of the recovery FV
+; Seg  = 0100h - (BlockNumber of Recovery FV)
+; Here 0FCh = 0100h - 04h
+;
+AP_SEG                      EQU   0FFh
+
+;
+; Commands defined in the AP SIPI code
+;
+AP_SIPI_COLLECT_MAX_RATIO   EQU   001h
+AP_SIPI_PROGRAM_MAX_RATIO   EQU   002h
+AP_SIPI_SWITCH_BSP          EQU   003h
diff --git a/QemuFspPkg/Library/PlatformSecLib/Ia32/SecEntry.nasm b/QemuFspPkg/Library/PlatformSecLib/Ia32/SecEntry.nasm
new file mode 100644
index 0000000000..b564667425
--- /dev/null
+++ b/QemuFspPkg/Library/PlatformSecLib/Ia32/SecEntry.nasm
@@ -0,0 +1,730 @@
+;; @file
+; This is the code that initializes CAR mode for QEMU.
+;
+; Copyright (c) 2017-2018 Intel Corporation.
+;
+; This program and the accompanying materials
+; are licensed and made available under the terms and conditions of the BSD License
+; which accompanies this distribution.  The full text of the license may be found at
+; http://opensource.org/licenses/bsd-license.php
+;
+; THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+; WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+;
+;------------------------------------------------------------------------------
+;;
+
+    SECTION .text
+
+;------------------------------------------------------------------------------
+  %include "PlatformNasm.inc"
+  %include "Ia32Nasm.inc"
+  %include "Chipset.inc"
+  %include "SecCoreNasm.inc"
+;
+; Define SSE macros
+;
+
+;
+;arg 1:RoutineLabel
+;
+%macro CALL_MMX   1
+         CALL_MMX_EXT  %1, mm7
+%endmacro
+
+%macro RET_ESI  0
+         RET_ESI_EXT   mm7
+%endmacro
+
+;
+;args 1: RoutineLabel  2:MmxRegister
+;
+%macro CALL_MMX_EXT  2
+  mov     esi, %%ReturnAddress
+  movd    %2, esi              ; save ReturnAddress into MMX
+  jmp     %1
+%%ReturnAddress:
+%endmacro
+
+;
+;args 1: ReturnAddress  2:MmxRegister
+;
+%macro LOAD_MMX_EXT 2
+  mov     esi, %1
+  movd    %2, esi              ; save ReturnAddress into MMX
+%endmacro
+
+;
+;arg 1:MmxRegister
+;
+%macro RET_ESI_EXT   1
+  movd    esi, %1              ; move ReturnAddress from MMX to ESI
+  jmp     esi
+%endmacro
+
+extern   ASM_PFX(PcdGet32(PcdFspTemporaryRamSize))
+extern   ASM_PFX(PcdGet32(PcdTemporaryRamBase))
+extern   ASM_PFX(PcdGet32(PcdTemporaryRamSize))
+extern   ASM_PFX(PcdGet32(PcdGlobalDataPointerAddress))
+extern   ASM_PFX(AsmGetFspInfoHeader)
+
+;_TEXT_PROTECTED_MODE      SEGMENT PARA PUBLIC USE32 'CODE'
+;ASSUME  CS:_TEXT_PROTECTED_MODE, DS:_TEXT_PROTECTED_MODE
+
+align 4
+global ASM_PFX(ProtectedModeSECStart)
+ASM_PFX(ProtectedModeSECStart):
+  jmp     $
+
+global ASM_PFX(SecPlatformInit)
+ASM_PFX(SecPlatformInit):
+  movd  ebp,  mm7
+
+  ;
+  ; Load return address into MMX to prepare return
+  ;
+
+  STATUS_CODE (0x3)
+  CALL_MMX  PlatformInitialization
+
+
+  ;
+  ; Check FSP Global pointer
+  ; It must have not been initialized
+  ;
+  mov       eax, [ASM_PFX(PcdGet32(PcdGlobalDataPointerAddress))]
+  mov       eax, dword [eax]
+  cmp       eax, 0
+  jz        FspGlobalPtrInvalid
+  cmp       eax, 0xFFFFFFFF
+  jz        FspGlobalPtrInvalid
+  mov       eax, 0x80000003
+  jmp       PlatformNemInitExit
+
+FspGlobalPtrInvalid:
+
+  ;
+  ; Set BIT16 and BIT17 in REG_SB_BIOS_CONFIG, Port 0x4, Offset 0x6.
+  ; These bits need to be set before setting bits [1:0] in BIOS_RESET_CPL
+  ; so that PUNIT will not power gate DFX.
+  ;
+  mov     edx, 0xCF8               ; Config MCD
+  mov     eax, 0x800000d4
+  out     dx,  eax
+
+  mov     edx, 0xCFC               ; Set BIT16 and BIT17
+  mov     eax, 0x30000
+  out     dx,  eax
+
+  mov     edx, 0xCF8               ; Config MCR
+  mov     eax, 0x800000d0
+  out     dx, eax
+
+  mov     edx, 0xCFC
+  mov     eax, 0x70406f0          ; Write_opcode + portID + offset
+  out     dx,  eax
+
+  ;
+  ; Set BIOS_RESET_DONE (BIT0) and BIOS_ALL_DONE (BIT1) in
+  ; PUNIT.BIOS_RESET_CPL register, Port 0x4, Offset 0x5.
+  ;
+  mov     edx, 0xCF8               ; Config MCD
+  mov     eax, 0x800000d4
+  out     dx,  eax
+
+  mov     edx, 0xCFC
+  mov     eax, 3                   ; Set BIT0 and BIT1
+  out     dx,  ax
+
+  mov     edx, 0xCF8               ; Config MCR
+  mov     eax, 0x800000d0
+  out     dx,  eax
+
+  mov     edx, 0xCFC
+  mov     eax, 0x70405f0          ; Write_opcode + portID + offset
+  out     dx,  eax
+
+  xor     eax, eax
+PlatformNemInitExit:
+  RET_ESI
+
+PlatformInitialization:
+  ;
+  ; Set RCBA base
+  ;
+  mov     edx, 0xCF8
+  mov     eax, 0x8000F8F0
+  out     dx,  eax
+  mov     edx, 0xCFC
+  mov     eax, PCH_RCBA_BASE_ADDRESS + 1
+  out     dx,  eax
+  ;
+  ; Enable HPET decoding
+  ;
+  mov     edx, PCH_RCBA_BASE_ADDRESS + 0x3404
+  mov     al,  0x80
+  mov     [edx], al
+
+  xor     eax, eax
+  jmp     ebp
+
+
+global ASM_PFX(SecCarInit)
+ASM_PFX(SecCarInit):
+  ;
+  ;  Enable cache for use as stack and for caching code
+  ;  The algorithm is specified in the processor BIOS writer's guide
+  ;
+
+  ;  Prevent this function from being optimized
+  mov  eax, ASM_PFX(AsmGetFspInfoHeader)
+
+  ;
+  ;  Ensure that the system is in flat 32 bit protected mode.
+  ;
+  ;  Platform Specific - configured earlier
+  ;
+  ;  Ensure that only one logical processor in the system is the BSP.
+  ;  (Required step for clustered systems).
+  ;
+  ;  Platform Specific - configured earlier
+
+  ;  Ensure all APs are in the Wait for SIPI state.
+  ;  This includes all other logical processors in the same physical processor
+  ;  as the BSP and all logical processors in other physical processors.
+  ;  If any APs are awake, the BIOS must put them back into the Wait for
+  ;  SIPI state by issuing a broadcast INIT IPI to all excluding self.
+  ;
+  mov     edi, APIC_ICR_LO               ; 0FEE00300h - Send INIT IPI to all excluding self
+  mov     eax, ORAllButSelf + ORSelfINIT ; 0000C4500h
+  mov     [edi], eax
+
+.1:
+  mov     eax, [edi]
+  bt      eax, 12                       ; Check if send is in progress
+  jc      .1                            ; Loop until idle
+
+  ;
+  ;   Load microcode update into BSP.
+  ;
+  ;   Ensure that all variable-range MTRR valid flags are clear and
+  ;   IA32_MTRR_DEF_TYPE MSR E flag is clear.  Note: This is the default state
+  ;   after hardware reset.
+  ;
+  ;   Platform Specific - MTRR are usually in default state.
+  ;
+
+  ;
+  ;   Initialize all fixed-range and variable-range MTRR register fields to 0.
+  ;
+   mov   ecx, IA32_MTRR_CAP         ; get variable MTRR support
+   rdmsr
+   movzx ebx, al                    ; EBX = number of variable MTRR pairs
+   shl   ebx, 2                     ; *4 for Base/Mask pair and WORD size
+   add   ebx, (MtrrCountFixed * 2)        ; EBX = size of  Fixed and Variable MTRRs
+
+   xor   eax, eax                       ; Clear the low dword to write
+   xor   edx, edx                       ; Clear the high dword to write
+
+InitMtrrLoop:
+   add   ebx, -2
+   movzx ecx, WORD [cs:(MtrrInitTable + ebx)]  ; ecx <- address of mtrr to zero
+   wrmsr
+   jnz   InitMtrrLoop                   ; loop through the whole table
+
+  ;
+  ;   Configure the default memory type to un-cacheable (UC) in the
+  ;   IA32_MTRR_DEF_TYPE MSR.
+  ;
+  mov     ecx, MTRR_DEF_TYPE            ; Load the MTRR default type index
+  rdmsr
+  and     eax, ~(00000CFFh)             ;Clear the enable bits and def type UC.
+  wrmsr
+
+  ; Configure MTRR_PHYS_MASK_HIGH for proper addressing above 4GB
+  ; based on the physical address size supported for this processor
+  ; This is based on read from CPUID EAX = 080000008h, EAX bits [7:0]
+  ;
+  ; Examples:
+  ;  MTRR_PHYS_MASK_HIGH = 00000000Fh  For 36 bit addressing
+  ;  MTRR_PHYS_MASK_HIGH = 0000000FFh  For 40 bit addressing
+  ;
+  mov   eax, 80000008h                  ; Address sizes leaf
+  cpuid
+  sub   al, 32
+  movzx eax, al
+  xor   esi, esi
+  bts   esi, eax
+  dec   esi                             ; esi <- MTRR_PHYS_MASK_HIGH
+
+  ;
+  ;   Configure the DataStack region as write-back (WB) cacheable memory type
+  ;   using the variable range MTRRs.
+  ;
+
+  ;
+  ; Set the base address of the DataStack cache range
+  ;
+  mov     eax, [ASM_PFX(PcdGet32 (PcdTemporaryRamBase))]
+  or      eax, MTRR_MEMORY_TYPE_WB
+                                        ; Load the write-back cache value
+  xor     edx, edx                      ; clear upper dword
+  mov     ecx, MTRR_PHYS_BASE_0         ; Load the MTRR index
+  wrmsr                                 ; the value in MTRR_PHYS_BASE_0
+
+  ;
+  ; Set the mask for the DataStack cache range
+  ; Compute MTRR mask value:  Mask = NOT (Size - 1)
+  ;
+  mov  eax, [ASM_PFX(PcdGet32 (PcdTemporaryRamSize))]
+  dec  eax
+  not  eax
+  or   eax, MTRR_PHYS_MASK_VALID
+                                        ; turn on the Valid flag
+  mov  edx, esi                         ; edx <- MTRR_PHYS_MASK_HIGH
+  mov  ecx, MTRR_PHYS_MASK_0            ; For proper addressing above 4GB
+  wrmsr                                 ; the value in MTRR_PHYS_BASE_0
+
+  ;
+  ;   Configure the BIOS code region as write-protected (WP) cacheable
+  ;   memory type using a single variable range MTRR.
+  ;
+  ;   Platform Specific - ensure region to cache meets MTRR requirements for
+  ;   size and alignment.
+  ;
+
+  ;
+  ; Set the base address of the CodeRegion cache range
+  ;
+  mov     eax, dword [esp + 0x04]
+  cmp     eax, 0
+  jz      InvalidParameter
+
+  mov     edi, dword [eax + 0x8]   ; Code regin base
+  mov     eax, dword [eax + 0xC]   ; Code regin size
+  cmp     eax,  0
+  jz      CodeRegionMtrrdone
+  cmp     edi, 0
+  jz      InvalidParameter
+  jmp     ValidateCodeBaseSize
+
+InvalidParameter:
+  mov     eax, 0x80000002              ; RETURN_INVALID_PARAMETER
+  jmp     InitializeNEMExit
+
+ValidateCodeBaseSize:
+  ;
+  ; Make sure the range length is power of 2
+  ;
+  bsr     ecx, eax                      ; Get the least significant set bit of 1 for length
+  bsf     edx, eax                      ; Get the reversed most significant set bit of 1 for length
+  cmp     ecx, edx
+  jnz     CheckFail
+
+  ;
+  ; Make sure the range base is aligned properly with the range length
+  ;
+  bsf     ecx, edi                      ; Get the least significant set bit of 1
+  cmp     ecx, edx
+  jae     CheckOk
+
+CheckFail:
+  mov     eax, 0x80000002               ; RETURN_INVALID_PARAMETER
+  jmp     InitializeNEMExit
+
+CheckOk:
+  ;
+  ; Define "local" vars for this routine
+  ; Note that mm0 is used to store BIST result for BSP,
+  ; mm1 is used to store the number of processor and BSP APIC ID,
+  ;
+  ;
+  %define CODE_SIZE_TO_CACHE      mm3
+  %define CODE_BASE_TO_CACHE      mm4
+  %define NEXT_MTRR_INDEX         mm5
+  %define NEXT_MTRR_SIZE          mm6
+  ;
+  ; Initialize "locals"
+  ;
+  sub     ecx, ecx
+  movd    NEXT_MTRR_INDEX, ecx          ; Count from 0 but start from MTRR_PHYS_BASE_1
+
+  ;
+  ; Save remaining size to cache
+  ;
+  movd    CODE_SIZE_TO_CACHE, eax       ; Size of code cache region that must be cached
+  movd    CODE_BASE_TO_CACHE, edi       ; Base code cache address
+
+NextMtrr:
+  ;
+  ; Get remaining size to cache
+  ;
+  movd    eax, CODE_SIZE_TO_CACHE
+  and     eax, eax
+  jz      CodeRegionMtrrdone            ; If no left size - we are done
+  ;
+  ; Determine next size to cache.
+  ; We start from bottom up. Use the following algorythm:
+  ; 1. Get our own alignment. Max size we can cache equals to our alignment
+  ; 2. Determine what is bigger - alignment or remaining size to cache.
+  ;    If aligment is bigger - cache it.
+  ;      Adjust remaing size to cache and base address
+  ;      Loop to 1.
+  ;    If remaining size to cache is bigger
+  ;      Determine the biggest 2^N part of it and cache it.
+  ;      Adjust remaing size to cache and base address
+  ;      Loop to 1.
+  ; 3. End when there is no left size to cache or no left MTRRs
+  ;
+  movd    edi, CODE_BASE_TO_CACHE
+  bsf     ecx, edi                      ; Get index of lowest bit set in base address
+  ;
+  ; Convert index into size to be cached by next MTRR
+  ;
+  mov     edx, 0x1
+  shl     edx, cl                       ; Alignment is in edx
+  cmp     edx, eax                      ; What is bigger, alignment or remaining size?
+  jbe     GotSize                       ; JIf aligment is less
+  ;
+  ; Remaining size is bigger. Get the biggest part of it, 2^N in size
+  ;
+  bsr     ecx, eax                      ; Get index of highest set bit
+  ;
+  ; Convert index into size to be cached by next MTRR
+  ;
+  mov     edx, 1
+  shl     edx, cl                       ; Size to cache
+
+GotSize:
+  mov     eax, edx
+  movd    NEXT_MTRR_SIZE, eax           ; Save
+
+  ;
+  ; Compute MTRR mask value:  Mask = NOT (Size - 1)
+  ;
+  dec     eax                           ; eax - size to cache less one byte
+  not     eax                           ; eax contains low 32 bits of mask
+  or      eax, MTRR_PHYS_MASK_VALID     ; Set valid bit
+
+  ;
+  ; Program mask register
+  ;
+  mov     ecx, MTRR_PHYS_MASK_1         ; setup variable mtrr
+  movd    ebx, NEXT_MTRR_INDEX
+  add     ecx, ebx
+
+  mov     edx, esi                      ; edx <- MTRR_PHYS_MASK_HIGH
+  wrmsr
+  ;
+  ; Program base register
+  ;
+  sub     edx, edx
+  mov     ecx, MTRR_PHYS_BASE_1         ; setup variable mtrr
+  add     ecx, ebx                      ; ebx is still NEXT_MTRR_INDEX
+
+  movd    eax, CODE_BASE_TO_CACHE
+  or      eax, MTRR_MEMORY_TYPE_WP      ; set type to write protect
+  wrmsr
+  ;
+  ; Advance and loop
+  ; Reduce remaining size to cache
+  ;
+  movd    ebx, CODE_SIZE_TO_CACHE
+  movd    eax, NEXT_MTRR_SIZE
+  sub     ebx, eax
+  movd    CODE_SIZE_TO_CACHE, ebx
+
+  ;
+  ; Increment MTRR index
+  ;
+  movd    ebx, NEXT_MTRR_INDEX
+  add     ebx, 2
+  movd    NEXT_MTRR_INDEX, ebx
+  ;
+  ; Increment base address to cache
+  ;
+  movd    ebx, CODE_BASE_TO_CACHE
+  movd    eax, NEXT_MTRR_SIZE
+  add     ebx, eax
+  movd    CODE_BASE_TO_CACHE, ebx
+
+  jmp     NextMtrr
+
+CodeRegionMtrrdone:
+;  ; Program the variable MTRR's MASK register for WDB
+;  ; (Write Data Buffer, used in MRC, must be WC type)
+;  ;
+;  mov     ecx, MTRR_PHYS_MASK_1
+;  movd    ebx, NEXT_MTRR_INDEX
+;  add     ecx, ebx
+;  mov     edx, esi                                          ; edx <- MTRR_PHYS_MASK_HIGH
+;  mov     eax, WDB_REGION_SIZE_MASK OR MTRR_PHYS_MASK_VALID ; turn on the Valid flag
+;  wrmsr
+
+;  ;
+;  ; Program the variable MTRR's BASE register for WDB
+;  ;
+;  dec     ecx
+;  xor     edx, edx
+;  mov     eax, WDB_REGION_BASE_ADDRESS OR MTRR_MEMORY_TYPE_WC
+;  wrmsr
+
+  ;
+  ; Enable the MTRRs by setting the IA32_MTRR_DEF_TYPE MSR E flag.
+  ;
+  mov     ecx, MTRR_DEF_TYPE            ; Load the MTRR default type index
+  rdmsr
+  or      eax, MTRR_DEF_TYPE_E          ; Enable variable range MTRRs
+  wrmsr
+
+NoL0x2Cace:
+  ;
+  ;   Enable the logical processor's (BSP) cache: execute INVD and set
+  ;   CR0.CD = 0, CR0.NW = 0.
+  ;
+  mov     eax, cr0
+  and     eax, ~ (CR0_CACHE_DISABLE + CR0_NO_WRITE)
+  invd
+  mov     cr0, eax
+  ;
+  ;   Enable No-Eviction Mode Setup State by setting
+  ;   NO_EVICT_MODE  MSR 2E0h bit [0] = '1'.
+  ;
+
+  ;   Skip MSR setting for QEMU to allow running with KVM
+%if 0
+  mov     ecx, NO_EVICT_MODE
+  rdmsr
+  or      eax, 1
+  wrmsr
+%endif
+
+  ;
+  ;   One location in each 64-byte cache line of the DataStack region
+  ;   must be written to set all cache values to the modified state.
+  ;
+  mov     edi, [ASM_PFX(PcdGet32(PcdTemporaryRamBase))]
+  mov     ecx, [ASM_PFX(PcdGet32(PcdTemporaryRamSize))]
+  shr     ecx, 6
+  mov     eax, CACHE_INIT_VALUE
+.3:
+  mov  [edi], eax
+  sfence
+  add  edi, 64
+  loop  .3
+
+  ;
+  ;   One location in each 64-byte cache line of the Code region
+  ;   must be written to set all cache values to the modified state.
+  ;
+  mov     edi, 0xFFFF8000
+  mov     ecx, 0x00008000
+  shr     ecx, 6
+.4:
+  mov  eax, [edi]
+  sfence
+  add  edi, 64
+  loop  .4
+
+  ;
+  ;   Enable No-Eviction Mode Run State by setting
+  ;   NO_EVICT_MODE MSR 2E0h bit [1] = '1'.
+  ;
+
+  ;   Skip MSR setting for QEMU to allow running with KVM
+%if 0
+  mov     ecx, NO_EVICT_MODE
+  rdmsr
+  or      eax, 2
+  wrmsr
+%endif
+
+  ;
+  ; Finished with cache configuration
+  ;
+
+  ;
+  ; Optionally Test the Region...
+  ;
+
+  ;
+  ; Test area by writing and reading
+  ;
+  cld
+  mov     edi, [ASM_PFX(PcdGet32 (PcdTemporaryRamBase))]
+  mov     ecx, [ASM_PFX(PcdGet32 (PcdTemporaryRamSize))]
+  shr     ecx, 2
+  mov     eax, CACHE_TEST_VALUE
+TestDataStackArea:
+  stosd
+  cmp     eax, DWORD [edi-4]
+  jnz     DataStackTestFail
+  loop    TestDataStackArea
+  jmp     DataStackTestPass
+
+  ;
+  ; Cache test failed
+  ;
+DataStackTestFail:
+  STATUS_CODE (0xD0)
+  jmp     $
+
+  ;
+  ; Configuration test failed
+  ;
+ConfigurationTestFailed:
+  STATUS_CODE (0xD1)
+  jmp     $
+
+DataStackTestPass:
+
+  ;
+  ; At this point you may continue normal execution.  Typically this would include
+  ; reserving stack, initializing the stack pointer, etc.
+  ;
+
+  ;
+  ; After memory initialization is complete, please follow the algorithm in the BIOS
+  ; Writer's Guide to properly transition to a normal system configuration.
+  ; The algorithm covers the required sequence to properly exit this mode.
+  ;
+  xor    eax, eax
+
+InitializeNEMExit:
+
+  RET_ESI
+
+align 16
+global ASM_PFX(BootGDTtable)
+
+;
+; GDT[0]: 0x00: Null entry, never used.
+;
+%define NULL_SEL $ - GDT_BASE        ; Selector [0]
+GDT_BASE:
+ASM_PFX(BootGDTtable):
+    DD  0
+    DD  0
+
+;
+; Linear data segment descriptor
+;
+%define LINEAR_SEL $ - GDT_BASE        ; Selector [0x8]
+    DW  0xFFFF                          ; limit 0xFFFFF
+    DW  0                               ; base 0
+    DB  0
+    DB  0x92                            ; present, ring 0, data, expand-up, writable
+    DB  0xCF                            ; page-granular, 32-bit
+    DB  0
+;
+; Linear code segment descriptor
+;
+%define LINEAR_CODE_SEL $ - GDT_BASE        ; Selector [0x10]
+    DW  0xFFFF                          ; limit 0xFFFFF
+    DW  0                               ; base 0
+    DB  0
+    DB  0x9B                            ; present, ring 0, data, expand-up, not-writable
+    DB  0xCF                            ; page-granular, 32-bit
+    DB  0
+;
+; System data segment descriptor
+;
+%define SYS_DATA_SEL $ - GDT_BASE        ; Selector [0x18]
+    DW  0xFFFF                          ; limit 0xFFFFF
+    DW  0                               ; base 0
+    DB  0
+    DB  0x93                            ; present, ring 0, data, expand-up, not-writable
+    DB  0xCF                            ; page-granular, 32-bit
+    DB  0
+
+;
+; System code segment descriptor
+;
+%define SYS_CODE_SEL $ - GDT_BASE        ; Selector [0x20]
+    DW  0xFFFF                          ; limit 0xFFFFF
+    DW  0                               ; base 0
+    DB  0
+    DB  0x9A                            ; present, ring 0, data, expand-up, writable
+    DB  0xCF                            ; page-granular, 32-bit
+    DB  0
+;
+; Spare segment descriptor
+;
+%define SYS16_CODE_SEL $ - GDT_BASE        ; Selector [0x28]
+    DW  0xFFFF                          ; limit 0xFFFFF
+    DW  0                               ; base 0
+    DB  0xE                             ; Changed from F000 to E000.
+    DB  0x9B                            ; present, ring 0, code, expand-up, writable
+    DB  0x0                             ; byte-granular, 16-bit
+    DB  0
+;
+; Spare segment descriptor
+;
+%define SYS16_DATA_SEL $ - GDT_BASE        ; Selector [0x30]
+    DW  0xFFFF                          ; limit 0xFFFF
+    DW  0                               ; base 0
+    DB  0
+    DB  0x93                            ; present, ring 0, data, expand-up, not-writable
+    DB  0x0                             ; byte-granular, 16-bit
+    DB  0
+
+;
+; Spare segment descriptor
+;
+%define SPARE5_SEL $ - GDT_BASE         ; Selector [0x38]
+    DW  0                               ; limit 0
+    DW  0                               ; base 0
+    DB  0
+    DB  0                               ; present, ring 0, data, expand-up, writable
+    DB  0                               ; page-granular, 32-bit
+    DB  0
+%define GDT_SIZE $ - ASM_PFX(BootGDTtable)    ; Size, in bytes
+
+global ASM_PFX(BootGdtDescr)
+GdtDesc:                                ; GDT descriptor
+%define OffsetGDTDesc $ - Flat32Start
+ASM_PFX(BootGdtDescr):
+    DW GDT_SIZE - 1                     ; GDT limit
+    DD ASM_PFX(BootGDTtable)            ; GDT base address
+
+ASM_PFX(NemInitLinearAddress):
+NemInitLinearOffset:
+    DD  ASM_PFX(ProtectedModeSECStart)  ; Offset of our 32 bit code
+    DW  LINEAR_CODE_SEL
+
+MtrrInitTable:
+    DW  MTRR_DEF_TYPE
+    DW  MTRR_FIX_64K_00000
+    DW  MTRR_FIX_16K_80000
+    DW  MTRR_FIX_16K_A0000
+    DW  MTRR_FIX_4K_C0000
+    DW  MTRR_FIX_4K_C8000
+    DW  MTRR_FIX_4K_D0000
+    DW  MTRR_FIX_4K_D8000
+    DW  MTRR_FIX_4K_E0000
+    DW  MTRR_FIX_4K_E8000
+    DW  MTRR_FIX_4K_F0000
+    DW  MTRR_FIX_4K_F8000
+
+MtrrCountFixed EQU (($ - MtrrInitTable) / 2)
+
+    DW  MTRR_PHYS_BASE_0
+    DW  MTRR_PHYS_MASK_0
+    DW  MTRR_PHYS_BASE_1
+    DW  MTRR_PHYS_MASK_1
+    DW  MTRR_PHYS_BASE_2
+    DW  MTRR_PHYS_MASK_2
+    DW  MTRR_PHYS_BASE_3
+    DW  MTRR_PHYS_MASK_3
+    DW  MTRR_PHYS_BASE_4
+    DW  MTRR_PHYS_MASK_4
+    DW  MTRR_PHYS_BASE_5
+    DW  MTRR_PHYS_MASK_5
+    DW  MTRR_PHYS_BASE_6
+    DW  MTRR_PHYS_MASK_6
+    DW  MTRR_PHYS_BASE_7
+    DW  MTRR_PHYS_MASK_7
+    DW  MTRR_PHYS_BASE_8
+    DW  MTRR_PHYS_MASK_8
+    DW  MTRR_PHYS_BASE_9
+    DW  MTRR_PHYS_MASK_9
diff --git a/QemuFspPkg/Library/PlatformSecLib/PlatformSecLib.c b/QemuFspPkg/Library/PlatformSecLib/PlatformSecLib.c
new file mode 100644
index 0000000000..f71759653c
--- /dev/null
+++ b/QemuFspPkg/Library/PlatformSecLib/PlatformSecLib.c
@@ -0,0 +1,85 @@
+/** @file
+  QEMU instance of Platform Sec Lib.
+
+  Copyright (c) 2017 - 2018, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php.
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+//
+// The package level header files this module uses
+//
+#include "PlatformSecLib.h"
+
+/**
+  Perform those platform specific operations that are requried to be executed as early as possibile.
+
+  @return TRUE always return true.
+**/
+EFI_STATUS
+EFIAPI
+PlatformSecLibConstructor (
+  )
+{
+  return EFI_SUCCESS;
+}
+
+/**
+  This function check the signture of UPD
+
+  @param[in]  ApiIdx           Internal index of the FSP API.
+  @param[in]  ApiParam         Parameter of the FSP API.
+
+**/
+
+EFI_STATUS
+EFIAPI
+FspUpdSignatureCheck (
+  IN UINT32   ApiIdx,
+  IN VOID     *ApiParam
+  )
+{
+  EFI_STATUS    Status;
+  FSPM_UPD      *FspmUpd;
+  FSPS_UPD      *FspsUpd;
+
+  Status = EFI_SUCCESS;
+  FspmUpd = NULL;
+  FspsUpd = NULL;
+
+  if (ApiIdx == FspMemoryInitApiIndex) {
+    //
+    // FspMemoryInit check
+    //
+    FspmUpd = (FSPM_UPD *)ApiParam;
+    if (FspmUpd != NULL) {
+      if ((FspmUpd->FspUpdHeader.Signature != FSPM_UPD_SIGNATURE)
+        || ((UINTN)FspmUpd->FspmArchUpd.StackBase == 0 )
+        || ((FspmUpd->FspmArchUpd.BootLoaderTolumSize % EFI_PAGE_SIZE) != 0)) {
+        Status = EFI_INVALID_PARAMETER;
+      }
+    }
+  } else if (ApiIdx == FspSiliconInitApiIndex) {
+    //
+    // FspSiliconInit check
+    //
+    FspsUpd = (FSPS_UPD *)ApiParam;
+    if (FspsUpd != NULL) {
+      if (FspsUpd->FspUpdHeader.Signature != FSPS_UPD_SIGNATURE) {
+        Status = EFI_INVALID_PARAMETER;
+      }
+    }
+  }
+
+  return Status;
+}
+
+
+
+
diff --git a/QemuFspPkg/Library/PlatformSecLib/PlatformSecLib.h b/QemuFspPkg/Library/PlatformSecLib/PlatformSecLib.h
new file mode 100644
index 0000000000..0ecdfbdbdf
--- /dev/null
+++ b/QemuFspPkg/Library/PlatformSecLib/PlatformSecLib.h
@@ -0,0 +1,48 @@
+/** @file
+  QEMU instance of Platform Sec Lib header file.
+
+  Copyright (c) 2017 - 2018, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php.
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#ifndef  _PLATFORM_SEC_LIB_H_
+#define  _PLATFORM_SEC_LIB_H_
+
+#include <PiPei.h>
+
+#include <Ppi/SecPlatformInformation.h>
+#include <Ppi/TemporaryRamSupport.h>
+
+#include <Library/BaseLib.h>
+#include <Library/PcdLib.h>
+#include <Library/BaseMemoryLib.h>
+#include <Library/FspCommonLib.h>
+#include <FspmUpd.h>
+#include <FspsUpd.h>
+
+#define Flat32Start                  _ModuleEntryPoint
+extern UINT32                        *TopOfCar;
+extern IA32_DESCRIPTOR                BootGdtDescr;
+
+#define DATA_LEN_OF_PER0 0x18
+#define DATA_LEN_OF_MCUD 0x18
+#define DATA_LEN_AT_TOP_OF_CAR (DATA_LEN_OF_PER0+DATA_LEN_OF_MCUD+4)
+
+FSP_INFO_HEADER *AsmGetFspInfoHeader (VOID);
+
+
+#endif
+
+
+
+
+
+
+
diff --git a/QemuFspPkg/Library/PlatformSecLib/Vtf0PlatformSecMLib.inf b/QemuFspPkg/Library/PlatformSecLib/Vtf0PlatformSecMLib.inf
new file mode 100644
index 0000000000..edaa85303b
--- /dev/null
+++ b/QemuFspPkg/Library/PlatformSecLib/Vtf0PlatformSecMLib.inf
@@ -0,0 +1,61 @@
+## @file
+#  QEMU instance of Platform Sec Lib for FSP-M.
+#
+#  Copyright (c) 2017 - 2018, Intel Corporation. All rights reserved.<BR>
+#
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution. The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php.
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+##
+
+################################################################################
+#
+# Defines Section - statements that will be processed to create a Makefile.
+#
+################################################################################
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = PlatformSecLibM
+  FILE_GUID                      = BA5CD127-1960-4fa0-B024-BA8EF79B5209
+  MODULE_TYPE                    = SEC
+  VERSION_STRING                 = 1.0
+  LIBRARY_CLASS                  = PlatformSecLib
+  CONSTRUCTOR                    = PlatformSecLibConstructor
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32
+#
+
+################################################################################
+#
+# Sources Section - list of files that are required for the build to succeed.
+#
+################################################################################
+
+[Sources]
+  PlatformSecLib.c
+  PlatformSecLib.h
+
+################################################################################
+#
+# Package Dependency Section - list of Package files that are required for
+#                              this module.
+#
+################################################################################
+
+[Packages]
+  MdePkg/MdePkg.dec
+  IntelFsp2Pkg/IntelFsp2Pkg.dec
+  QemuFspPkg/QemuFspPkg.dec
+
+[LibraryClasses]
+
+[Pcd]
+  gIntelFsp2PkgTokenSpaceGuid.PcdTemporaryRamBase
+  gIntelFsp2PkgTokenSpaceGuid.PcdTemporaryRamSize
diff --git a/QemuFspPkg/Library/PlatformSecLib/Vtf0PlatformSecSLib.inf b/QemuFspPkg/Library/PlatformSecLib/Vtf0PlatformSecSLib.inf
new file mode 100644
index 0000000000..d2f841ad2e
--- /dev/null
+++ b/QemuFspPkg/Library/PlatformSecLib/Vtf0PlatformSecSLib.inf
@@ -0,0 +1,63 @@
+## @file
+#  QEMU instance of Platform Sec Lib for FSP-S.
+#
+#  Copyright (c) 2017 - 2018, Intel Corporation. All rights reserved.<BR>
+#
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution. The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php.
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+##
+
+################################################################################
+#
+# Defines Section - statements that will be processed to create a Makefile.
+#
+################################################################################
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = PlatformSecLibM
+  FILE_GUID                      = BA5CD127-1960-4fa0-B024-BA8EF79B5209
+  MODULE_TYPE                    = SEC
+  VERSION_STRING                 = 1.0
+  LIBRARY_CLASS                  = PlatformSecLib
+  CONSTRUCTOR                    = PlatformSecLibConstructor
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32
+#
+
+################################################################################
+#
+# Sources Section - list of files that are required for the build to succeed.
+#
+################################################################################
+
+[Sources]
+  PlatformSecLib.c
+  PlatformSecLib.h
+
+
+
+################################################################################
+#
+# Package Dependency Section - list of Package files that are required for
+#                              this module.
+#
+################################################################################
+
+[Packages]
+  MdePkg/MdePkg.dec
+  IntelFsp2Pkg/IntelFsp2Pkg.dec
+  QemuFspPkg/QemuFspPkg.dec
+
+[LibraryClasses]
+
+[Pcd]
+  gIntelFsp2PkgTokenSpaceGuid.PcdTemporaryRamBase
+  gIntelFsp2PkgTokenSpaceGuid.PcdTemporaryRamSize
diff --git a/QemuFspPkg/Library/PlatformSecLib/Vtf0PlatformSecTLib.inf b/QemuFspPkg/Library/PlatformSecLib/Vtf0PlatformSecTLib.inf
new file mode 100644
index 0000000000..2f80ba02d2
--- /dev/null
+++ b/QemuFspPkg/Library/PlatformSecLib/Vtf0PlatformSecTLib.inf
@@ -0,0 +1,67 @@
+## @file
+#  QEMU instance of Platform Sec Lib for FSP-T.
+#
+#  Copyright (c) 2017 - 2018, Intel Corporation. All rights reserved.<BR>
+#
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution. The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php.
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+##
+
+################################################################################
+#
+# Defines Section - statements that will be processed to create a Makefile.
+#
+################################################################################
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = PlatformSecLibT
+  FILE_GUID                      = BA5CD127-1960-4fa0-B024-BA8EF79B5209
+  MODULE_TYPE                    = SEC
+  VERSION_STRING                 = 1.0
+  LIBRARY_CLASS                  = PlatformSecLib
+  CONSTRUCTOR                    = PlatformSecLibConstructor
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32
+#
+
+################################################################################
+#
+# Sources Section - list of files that are required for the build to succeed.
+#
+################################################################################
+
+[Sources]
+  PlatformSecLib.c
+  PlatformSecLib.h
+
+[Sources.IA32]
+  Ia32/SecEntry.nasm
+
+################################################################################
+#
+# Package Dependency Section - list of Package files that are required for
+#                              this module.
+#
+################################################################################
+
+[Packages]
+  MdePkg/MdePkg.dec
+  IntelFsp2Pkg/IntelFsp2Pkg.dec
+  QemuFspPkg/QemuFspPkg.dec
+
+[LibraryClasses]
+
+[Pcd]
+  gIntelFsp2PkgTokenSpaceGuid.PcdTemporaryRamBase
+  gIntelFsp2PkgTokenSpaceGuid.PcdTemporaryRamSize
+  gIntelFsp2PkgTokenSpaceGuid.PcdFspTemporaryRamSize
+  gIntelFsp2PkgTokenSpaceGuid.PcdGlobalDataPointerAddress
+
diff --git a/QemuFspPkg/QemuFspPkg.dec b/QemuFspPkg/QemuFspPkg.dec
new file mode 100644
index 0000000000..8c437138ed
--- /dev/null
+++ b/QemuFspPkg/QemuFspPkg.dec
@@ -0,0 +1,51 @@
+## @file
+# FSP package PCD definitions for QEMU platform
+#
+# Copyright (c) 2017 - 2018, Intel Corporation. All rights reserved.<BR>
+#
+#    This program and the accompanying materials
+#    are licensed and made available under the terms and conditions of the BSD License
+#    which accompanies this distribution. The full text of the license may be found at
+#    http://opensource.org/licenses/bsd-license.php
+#
+#    THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#    WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+##
+
+[Defines]
+  DEC_SPECIFICATION              = 0x00010005
+  PACKAGE_NAME                   = QemuFspPkg
+  PACKAGE_GUID                   = F4D5D60C-8052-444a-9078-6B863EF5B540
+  PACKAGE_VERSION                = 1.02
+
+[Includes]
+  Include
+
+[Guids]
+  #
+  # GUID defined in package
+  #
+  gQemuFspPkgTokenSpaceGuid  = { 0x2aef6cb8, 0x2fc4, 0x47ef, { 0x85, 0xc7, 0x16, 0xfb, 0xe2, 0xae, 0xe3, 0xbd }}
+  gFspSiliconFvGuid          = { 0x1b5c27fe, 0xf01c, 0x4fbc, { 0xae, 0xae, 0x34, 0x1b, 0x2e, 0x99, 0x2a, 0x17 }}
+  gFspReservedMemoryResourceHobTsegGuid  =  { 0xd038747c, 0xd00c, 0x4980, { 0xb3, 0x19, 0x49, 0x01, 0x99, 0xa4, 0x7d, 0x55}}
+
+[PcdsFixedAtBuild]
+  gQemuFspPkgTokenSpaceGuid.PcdFspStackTopReservedSize    | 0x00000000           | UINT32  | 0x00000002
+  gQemuFspPkgTokenSpaceGuid.PcdFlashFvFsptBase            | 0x00000000           | UINT32  | 0x00000003
+  gQemuFspPkgTokenSpaceGuid.PcdFlashFvFsptSize            | 0x00000000           | UINT32  | 0x00000005
+  gQemuFspPkgTokenSpaceGuid.PcdFlashFvFspmBase            | 0x00000000           | UINT32  | 0x00000006
+  gQemuFspPkgTokenSpaceGuid.PcdFlashFvFspmSize            | 0x00000000           | UINT32  | 0x00000008
+  gQemuFspPkgTokenSpaceGuid.PcdFlashFvFspsBase            | 0x00000000           | UINT32  | 0x00000009
+  gQemuFspPkgTokenSpaceGuid.PcdFlashFvFspsSize            | 0x00000000           | UINT32  | 0x0000000A
+  gQemuFspPkgTokenSpaceGuid.PcdFspHeaderRevision          | 0x02                 | UINT8   | 0x00000011
+  gQemuFspPkgTokenSpaceGuid.PcdFspImageRevision           | 0x00000000           | UINT32  | 0x00000012
+  gQemuFspPkgTokenSpaceGuid.PcdFspImageIdString           | 0x245053464D455124   | UINT64  | 0x00000013 #$QEMFSP$
+  gQemuFspPkgTokenSpaceGuid.PcdFspImageAttributes         | 0x0000               | UINT16  | 0x00000015 #BIT0 Graphics supported
+  gQemuFspPkgTokenSpaceGuid.PcdFspComponentAttributes     | 0x0000               | UINT16  | 0x00000016 #Bits[15:12] - 0001b: FSP-T, 0010b: FSP-M, 0011b: FSP-S
+
+[PcdsFeatureFlag]
+  gQemuFspPkgTokenSpaceGuid.PcdStatusCodeUseIsaSerial     | TRUE                 | BOOLEAN | 0x00000017
+
+
+
diff --git a/QemuFspPkg/QemuFspPkg.dsc b/QemuFspPkg/QemuFspPkg.dsc
new file mode 100644
index 0000000000..2abb3abf89
--- /dev/null
+++ b/QemuFspPkg/QemuFspPkg.dsc
@@ -0,0 +1,436 @@
+## @file
+# FSP DSC build file for QEMU platform
+#
+# Copyright (c) 2017 - 2018, Intel Corporation. All rights reserved.<BR>
+#
+#    This program and the accompanying materials
+#    are licensed and made available under the terms and conditions of the BSD License
+#    which accompanies this distribution. The full text of the license may be found at
+#    http://opensource.org/licenses/bsd-license.php
+#
+#    THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#    WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+##
+
+[Defines]
+  #
+  # Set platform specific package/folder name, same as passed from PREBUILD script.
+  # PLATFORM_PACKAGE would be the same as PLATFORM_NAME as well as package build folder
+  # DEFINE only takes effect at R9 DSC and FDF.
+  #
+  DEFINE FSP_PACKAGE                     = QemuFspPkg
+  DEFINE FSP_IMAGE_ID                    = 0x245053464D455124  # $QEMFSP$
+  DEFINE FSP_IMAGE_REV                   = 0x00001000
+
+  DEFINE CAR_BASE_ADDRESS                = 0x00000000
+  DEFINE CAR_REGION_SIZE                 = 0x00080000
+  DEFINE CAR_BLD_REGION_SIZE             = 0x00070000
+  DEFINE CAR_FSP_REGION_SIZE             = 0x00010000
+
+################################################################################
+#
+# Defines Section - statements that will be processed to create a Makefile.
+#
+################################################################################
+[Defines]
+  PLATFORM_NAME                  = QemuFspPkg
+  PLATFORM_GUID                  = 1BEDB57A-7904-406e-8486-C89FC7FB39EE
+  PLATFORM_VERSION               = 0.1
+  DSC_SPECIFICATION              = 0x00010005
+  OUTPUT_DIRECTORY               = Build/QemuFspPkg
+  SUPPORTED_ARCHITECTURES        = IA32
+  BUILD_TARGETS                  = DEBUG|RELEASE
+  SKUID_IDENTIFIER               = DEFAULT
+  FLASH_DEFINITION               = QemuFspPkg/QemuFspPkg.fdf
+
+  #
+  # UPD tool definition
+  #
+  FSP_T_UPD_TOOL_GUID            = 34686CA3-34F9-4901-B82A-BA630F0714C6
+  FSP_M_UPD_TOOL_GUID            = 39A250DB-E465-4DD1-A2AC-E2BD3C0E2385
+  FSP_S_UPD_TOOL_GUID            = CAE3605B-5B34-4C85-B3D7-27D54273C40F
+  FSP_T_UPD_FFS_GUID             = 70BCF6A5-FFB1-47D8-B1AE-EFE5508E23EA
+  FSP_M_UPD_FFS_GUID             = D5B86AEA-6AF7-40D4-8014-982301BC3D89
+  FSP_S_UPD_FFS_GUID             = E3CD9B18-998C-4F76-B65E-98B154E5446F
+
+################################################################################
+#
+# SKU Identification section - list of all SKU IDs supported by this
+#                              Platform.
+#
+################################################################################
+[SkuIds]
+  0|DEFAULT              # The entry: 0|DEFAULT is reserved and always required.
+
+################################################################################
+#
+# Library Class section - list of all Library Classes needed by this Platform.
+#
+################################################################################
+
+[LibraryClasses]
+  PeiCoreEntryPoint|MdePkg/Library/PeiCoreEntryPoint/PeiCoreEntryPoint.inf
+  PeimEntryPoint|MdePkg/Library/PeimEntryPoint/PeimEntryPoint.inf
+  DebugPrintErrorLevelLib|MdePkg/Library/BaseDebugPrintErrorLevelLib/BaseDebugPrintErrorLevelLib.inf
+  BaseLib|MdePkg/Library/BaseLib/BaseLib.inf
+  IoLib|MdePkg/Library/BaseIoLibIntrinsic/BaseIoLibIntrinsic.inf
+  PciLib|MdePkg/Library/BasePciLibPciExpress/BasePciLibPciExpress.inf
+  PciCf8Lib|MdePkg/Library/BasePciCf8Lib/BasePciCf8Lib.inf
+  PciExpressLib|MdePkg/Library/BasePciExpressLib/BasePciExpressLib.inf
+  BaseMemoryLib|MdePkg/Library/BaseMemoryLibRepStr/BaseMemoryLibRepStr.inf
+  PrintLib|MdePkg/Library/BasePrintLib/BasePrintLib.inf
+  PcdLib|MdePkg/Library/PeiPcdLib/PeiPcdLib.inf
+  HobLib|MdePkg/Library/PeiHobLib/PeiHobLib.inf
+  PeiServicesTablePointerLib|MdePkg/Library/PeiServicesTablePointerLibIdt/PeiServicesTablePointerLibIdt.inf
+  PeiServicesLib|MdePkg/Library/PeiServicesLib/PeiServicesLib.inf
+  MemoryAllocationLib|MdePkg/Library/PeiMemoryAllocationLib/PeiMemoryAllocationLib.inf
+  PeCoffGetEntryPointLib|MdePkg/Library/BasePeCoffGetEntryPointLib/BasePeCoffGetEntryPointLib.inf
+  ReportStatusCodeLib|MdeModulePkg/Library/PeiReportStatusCodeLib/PeiReportStatusCodeLib.inf
+  CacheMaintenanceLib|MdePkg/Library/BaseCacheMaintenanceLib/BaseCacheMaintenanceLib.inf
+  PeCoffLib|MdePkg/Library/BasePeCoffLib/BasePeCoffLib.inf
+  PeCoffExtraActionLib|MdePkg/Library/BasePeCoffExtraActionLibNull/BasePeCoffExtraActionLibNull.inf
+  UefiDecompressLib|MdePkg/Library/BaseUefiDecompressLib/BaseUefiDecompressLib.inf
+  SynchronizationLib|MdePkg/Library/BaseSynchronizationLib/BaseSynchronizationLib.inf
+  CpuLib|MdePkg/Library/BaseCpuLib/BaseCpuLib.inf
+  UefiCpuLib|UefiCpuPkg/Library/BaseUefiCpuLib/BaseUefiCpuLib.inf
+  ExtractGuidedSectionLib|MdePkg/Library/PeiExtractGuidedSectionLib/PeiExtractGuidedSectionLib.inf
+  CacheLib|IntelFsp2Pkg/Library/BaseCacheLib/BaseCacheLib.inf
+  CacheAsRamLib|IntelFsp2Pkg/Library/BaseCacheAsRamLibNull/BaseCacheAsRamLibNull.inf
+  FspSwitchStackLib|IntelFsp2Pkg/Library/BaseFspSwitchStackLib/BaseFspSwitchStackLib.inf
+  FspCommonLib|IntelFsp2Pkg/Library/BaseFspCommonLib/BaseFspCommonLib.inf
+  FspPlatformLib|IntelFsp2Pkg/Library/BaseFspPlatformLib/BaseFspPlatformLib.inf
+  PlatformHookLib|MdeModulePkg/Library/BasePlatformHookLibNull/BasePlatformHookLibNull.inf
+  PerformanceLib|MdePkg/Library/BasePerformanceLibNull/BasePerformanceLibNull.inf
+  OemHookStatusCodeLib|MdeModulePkg/Library/OemHookStatusCodeLibNull/OemHookStatusCodeLibNull.inf
+!if $(TARGET) == DEBUG
+  DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
+  SerialPortLib|MdeModulePkg/Library/BaseSerialPortLib16550/BaseSerialPortLib16550.inf
+!else
+  DebugLib|MdePkg/Library/BaseDebugLibNull/BaseDebugLibNull.inf
+  SerialPortLib|MdePkg/Library/BaseSerialPortLibNull/BaseSerialPortLibNull.inf
+!endif
+
+
+################################################################################
+#
+# Pcd Section - list of all EDK II PCD Entries defined by this Platform
+#
+################################################################################
+[PcdsFixedAtBuild]
+  gEfiMdeModulePkgTokenSpaceGuid.PcdShadowPeimOnS3Boot    | TRUE
+  gQemuFspPkgTokenSpaceGuid.PcdFspHeaderRevision          | 0x03
+  gQemuFspPkgTokenSpaceGuid.PcdFspImageIdString           | $(FSP_IMAGE_ID)
+  gQemuFspPkgTokenSpaceGuid.PcdFspImageRevision           | $(FSP_IMAGE_REV)
+  #
+  # FSP CAR Usages  (BL RAM | FSP RAM | FSP CODE)
+  #
+  gIntelFsp2PkgTokenSpaceGuid.PcdTemporaryRamBase         | $(CAR_BASE_ADDRESS)
+  gIntelFsp2PkgTokenSpaceGuid.PcdTemporaryRamSize         | $(CAR_REGION_SIZE)
+  gIntelFsp2PkgTokenSpaceGuid.PcdFspTemporaryRamSize      | $(CAR_FSP_REGION_SIZE)
+  gIntelFsp2PkgTokenSpaceGuid.PcdFspReservedBufferSize    | 0x0100
+
+  # This defines how much space will be used for heap in FSP temporary memory
+  # x % of FSP temporary memory will be used for heap
+  # (100 - x) % of FSP temporary memory will be used for stack
+  gIntelFsp2PkgTokenSpaceGuid.PcdFspHeapSizePercentage    | 65
+
+  # This is a platform specific global pointer used by FSP
+  gIntelFsp2PkgTokenSpaceGuid.PcdGlobalDataPointerAddress | 0xFED00148
+  gIntelFsp2PkgTokenSpaceGuid.PcdFspReservedMemoryLength  | 0x00100000
+
+!if $(TARGET) == RELEASE
+  gEfiMdePkgTokenSpaceGuid.PcdFixedDebugPrintErrorLevel   | 0x00000000
+  gEfiMdePkgTokenSpaceGuid.PcdDebugPropertyMask           | 0
+!else
+  gEfiMdePkgTokenSpaceGuid.PcdFixedDebugPrintErrorLevel   | 0x80000047
+  gEfiMdePkgTokenSpaceGuid.PcdDebugPropertyMask           | 0x27
+!endif
+
+[PcdsPatchableInModule]
+  gEfiMdePkgTokenSpaceGuid.PcdPciExpressBaseAddress       | 0xE0000000
+  #
+  # This entry will be patched during the build process
+  #
+  gEfiMdeModulePkgTokenSpaceGuid.PcdVpdBaseAddress        | 0x12345678
+
+!if $(TARGET) == RELEASE
+  gEfiMdePkgTokenSpaceGuid.PcdDebugPrintErrorLevel        | 0
+!else
+  gEfiMdePkgTokenSpaceGuid.PcdDebugPrintErrorLevel        | 0x80000047
+!endif
+
+[PcdsDynamicVpd.Upd]
+  #
+  # This section is not used by the normal build process
+  # However, FSP will use dedicated tool to handle it and generate a
+  # VPD similar binary block (User Configuration Data). This block will
+  # be accessed through a generated data structure directly rather than
+  # PCD services. This is for size consideration.
+  # Format:
+  #   gQemuFspPkgTokenSpaceGuid.Updxxxxxxxxxxxxn      | OFFSET | LENGTH | VALUE
+  # Only simple data type is supported
+  #
+
+  #
+  # Comments with !BSF will be used to generate BSF file
+  # Comments with !HDR will be used to generate H header file
+  #
+
+  # Global definitions in BSF
+  # !BSF PAGES:{MEM:"FSP MemoryInit Settings", SIL:"FSP SiliconInit Settings"}
+  # !BSF BLOCK:{NAME:"Apollo Lake Platform", VER:"0.1"}
+
+  # !BSF FIND:{APLUPD_T}
+  # !HDR COMMENT:{FSP_UPD_HEADR:FSP UPD Header}
+  # !HDR EMBED:{FSP_UPD_HEADER:FspUpdHeader:START}
+  # FsptUpdSignature: {QEMUPD_T}
+  gQemuFspPkgTokenSpaceGuid.Signature                   | 0x0000 | 0x08 | 0x545F4450554D4551
+  # !BSF NAME:{FsptUpdRevision}  TYPE:{None}
+  gQemuFspPkgTokenSpaceGuid.Revision                    | 0x0008 | 0x01 | 0x01
+  # !HDR EMBED:{FSP_UPD_HEADER:FspUpdHeader:END}
+  gQemuFspPkgTokenSpaceGuid.Reserved                    | 0x0009 | 0x17 | {0x00}
+
+  # !HDR COMMENT:{FSPT_COMMON_UPD:Fsp T Common UPD}
+  # !HDR EMBED:{FSPT_COMMON_UPD:FsptCommonUpd:START}
+  gQemuFspPkgTokenSpaceGuid.Revision                    | 0x0020 | 0x01 | 0x01
+  gQemuFspPkgTokenSpaceGuid.Reserved                    | 0x0021 | 0x03 | {0x00}
+
+  # Base address of the microcode region.
+  gQemuFspPkgTokenSpaceGuid.MicrocodeRegionBase         | 0x0024 | 0x04 | 0x00000000
+
+  # Length of the microcode region.
+  gQemuFspPkgTokenSpaceGuid.MicrocodeRegionLength       | 0x0028 | 0x04 | 0x00000000
+
+  # Base address of the cacheable flash region.
+  gQemuFspPkgTokenSpaceGuid.CodeRegionBase              | 0x002C | 0x04 | 0x00000000
+
+  # Length of the cacheable flash region.
+  gQemuFspPkgTokenSpaceGuid.CodeRegionLength            | 0x0030 | 0x04 | 0x00000000
+
+  # !HDR EMBED:{FSPT_COMMON_UPD:FsptCommonUpd:END}
+  gQemuFspPkgTokenSpaceGuid.Reserved1                   | 0x0034 | 0x0C | {0x00}
+
+  # !HDR COMMENT:{FSP_T_CONFIG:Fsp T Configuration}
+  # !HDR EMBED:{FSP_T_CONFIG:FsptConfig:START}
+
+  # !HDR EMBED:{FSP_T_CONFIG:FsptConfig:END}
+  gQemuFspPkgTokenSpaceGuid.ReservedFsptUpd1             | 0x0040 | 0x20 | {0x00}
+
+  # Note please keep "UpdTerminator" at the end of each UPD region.
+  # The tool will use this field to determine the actual end of the UPD data
+  # structure.
+  gQemuFspPkgTokenSpaceGuid.UpdTerminator               | 0x0090 | 0x02 | 0x55AA
+
+  ################################################################################
+  #
+  # UPDs consumed in FspMemoryInit Api
+  #
+  ################################################################################
+  # !BSF FIND:{APLUPD_M}
+  # !HDR COMMENT:{FSP_UPD_HEADER:FSP UPD Header}
+  # !HDR EMBED:{FSP_UPD_HEADER:FspUpdHeader:START}
+  # FspmUpdSignature: {APLUPD_M}
+  gQemuFspPkgTokenSpaceGuid.Signature                   | 0x0000 | 0x08 | 0x4D5F4450554D4551
+  # !BSF NAME:{FspmUpdRevision}  TYPE:{None}
+  gQemuFspPkgTokenSpaceGuid.Revision                    | 0x0008 | 0x01 | 0x01
+  # !HDR EMBED:{FSP_UPD_HEADER:FspUpdHeader:END}
+  gQemuFspPkgTokenSpaceGuid.Reserved                    | 0x0009 | 0x17 | {0x00}
+
+  # !HDR COMMENT:{FSPM_ARCH_UPD:Fsp M Architectural UPD}
+  # !HDR EMBED:{FSPM_ARCH_UPD:FspmArchUpd:START}
+  # !BSF PAGE:{MEM}
+
+  gQemuFspPkgTokenSpaceGuid.Revision                    | 0x0020 | 0x01 | 0x01
+
+  gQemuFspPkgTokenSpaceGuid.Reserved                    | 0x0021 | 0x03 | {0x00}
+
+  # !HDR STRUCT:{VOID*}
+  gQemuFspPkgTokenSpaceGuid.NvsBufferPtr                | 0x0024 | 0x04 | 0x00000000
+
+  # !HDR STRUCT:{VOID*}
+  # !BSF NAME:{StackBase}
+  # !BSF HELP:{Stack base for FSP use. Default: 0xFEF16000}
+  gQemuFspPkgTokenSpaceGuid.StackBase                   | 0x0028 | 0x04 | $(CAR_BLD_REGION_SIZE)
+
+  # !BSF NAME:{StackSize}
+  # !BSF HELP:{To pass the stack size for FSP use. Bootloader can programmatically get the FSP requested StackSize by using the defaults in the FSP-M component. This is the minimum stack size expected by this revision of FSP. Default: 0x2A000}
+  gQemuFspPkgTokenSpaceGuid.StackSize                   | 0x002C | 0x04 | $(CAR_FSP_REGION_SIZE)
+
+  # !BSF NAME:{BootLoaderTolumSize}
+  # !BSF HELP:{To pass Bootloader Tolum size.}
+  gQemuFspPkgTokenSpaceGuid.BootLoaderTolumSize         | 0x0030 | 0x04 | 0x00000000
+
+  # !BSF NAME:{Bootmode}
+  # !BSF HELP:{To maintain Bootmode details.}
+  gPlatformFspPkgTokenSpaceGuid.Bootmode                   | 0x0034 | 0x04 | 0x00000000
+
+  # !HDR EMBED:{FSPM_ARCH_UPD:FspmArchUpd:END}
+  gQemuFspPkgTokenSpaceGuid.Reserved1                   | 0x0038 | 0x08 | {0x00}
+
+  # !HDR COMMENT:{FSP_M_CONFIG:Fsp M Configuration}
+  # !HDR EMBED:{FSP_M_CONFIG:FspmConfig:START}
+  # !BSF NAME:{Debug Serial Port Base address}
+  # !BSF TYPE:{EditNum, HEX, (0x00000000,0xFFFFFFFF)}
+  # !BSF HELP:{Debug serial port base address. This option will be used only when the 'Serial Port Debug Device'}
+  # !BSF HELP:{+ option is set to 'External Device'. 0x00000000(Default).}
+  gQemuFspPkgTokenSpaceGuid.SerialDebugPortAddress      | 0x0040 | 0x04 | 0x00000000
+
+  # !BSF NAME:{Debug Serial Port Type} TYPE:{Combo}
+  # !BSF OPTION:{0:NONE, 1:I/O, 2:MMIO}
+  # !BSF HELP:{16550 compatible debug serial port resource type. NONE means no serial port support. 0x02:MMIO(Default).}
+  gQemuFspPkgTokenSpaceGuid.SerialDebugPortType         | 0x0044 | 0x01 | 0x02
+
+  # !BSF NAME:{Serial Port Debug Device} TYPE:{Combo}
+  # !BSF OPTION:{0:SOC UART0, 1:SOC UART1, 2:SOC UART2, 3:External Device}
+  # !BSF HELP:{Select active serial port device for debug. }
+  # !BSF HELP:{+For SOC UART devices,'Debug Serial Port Base' options will be ignored. 0x02:SOC UART2(Default).}
+  gQemuFspPkgTokenSpaceGuid.SerialDebugPortDevice       | 0x0045 | 0x01 | 0x02
+
+  # !BSF NAME:{Debug Serial Port Stride Size} TYPE:{Combo}
+  # !BSF OPTION:{0:1, 2:4}
+  # !BSF HELP:{Debug serial port register map stride size in bytes. 0x00:1, 0x02:4(Default).}
+  gQemuFspPkgTokenSpaceGuid.SerialDebugPortStrideSize   | 0x0046 | 0x01 | 0x02
+
+
+  # !HDR EMBED:{FSP_M_CONFIG:FspmConfig:END}
+  gQemuFspPkgTokenSpaceGuid.ReservedFspmUpd             | 0x0078 | 0x04 | {0x00}
+
+
+  # Note please keep "UpdTerminator" at the end of each UPD region.
+  # The tool will use this field to determine the actual end of the UPD data
+  # structure.
+  gQemuFspPkgTokenSpaceGuid.UpdTerminator               | 0x007E | 0x02 | 0x55AA
+
+  ################################################################################
+  #
+  # UPDs consumed in FspSiliconInit Api
+  #
+  ################################################################################
+  # !BSF FIND:{APLUPD_S}
+  # !HDR COMMENT:{FSP_UPD_HEADER:FSP UPD Header}
+  # !HDR EMBED:{FSP_UPD_HEADER:FspUpdHeader:START}
+  # FspsUpdSignature: {APLUPD_S}
+  gQemuFspPkgTokenSpaceGuid.Signature                   | 0x0000 | 0x08 | 0x535F4450554D4551
+  # !BSF NAME:{FspsUpdRevision}  TYPE:{None}
+  gQemuFspPkgTokenSpaceGuid.Revision                    | 0x0008 | 0x01 | 0x01
+  # !HDR EMBED:{FSP_UPD_HEADER:FspUpdHeader:END}
+  gQemuFspPkgTokenSpaceGuid.Reserved                    | 0x0009 | 0x17 | {0x00}
+
+  # !HDR COMMENT:{FSP_S_CONFIG:Fsp S Configuration}
+  # !HDR EMBED:{FSP_S_CONFIG:FspsConfig:START}
+  # !BSF PAGE:{SIL}
+
+  # !BSF NAME:{BMP Logo Data Size}
+  # !BSF TYPE:{Reserved}
+  # !BSF HELP:{BMP logo data buffer size. 0x00000000(Default).}
+  gQemuFspPkgTokenSpaceGuid.LogoSize                    | 0x0040 | 0x04 | 0x00000000
+
+  # !BSF NAME:{BMP Logo Data Pointer}
+  # !BSF TYPE:{Reserved}
+  # !BSF HELP:{BMP logo data pointer to a BMP format buffer. 0x00000000(Default).}
+  gQemuFspPkgTokenSpaceGuid.LogoPtr                     | 0x0044 | 0x04 | 0x00000000
+
+  # !BSF NAME:{Graphics Configuration Data Pointer}
+  # !BSF TYPE:{Reserved}
+  # !BSF HELP:{Graphics configuration data used for initialization. 0x00000000(Default).}
+  gQemuFspPkgTokenSpaceGuid.GraphicsConfigPtr           | 0x0048 | 0x04 | 0x00000000
+
+  # !BSF NAME:{PCI Temporary MMIO Base}
+  # !BSF TYPE:{Reserved}
+  # !BSF HELP:{PCI Temporary MMIO Base used before full PCI enumeration. 0x80000000(Default).}
+  gQemuFspPkgTokenSpaceGuid.PciTempResourceBase         | 0x004C | 0x04 | 0x80000000
+
+  # !HDR EMBED:{FSP_S_CONFIG:FspsConfig:END}
+  gQemuFspPkgTokenSpaceGuid.ReservedFspsUpd             | 0x0070 | 0x01 | 0x00
+
+  # Note please keep "UpdTerminator" at the end of each UPD region.
+  # The tool will use this field to determine the actual end of the UPD data
+  # structure.
+  gQemuFspPkgTokenSpaceGuid.UpdTerminator               | 0x007E | 0x02 | 0x55AA
+
+###################################################################################################
+#
+# Components Section - list of the modules and components that will be processed by compilation
+#                      tools and the EDK II tools to generate PE32/PE32+/Coff image files.
+#
+# Note: The EDK II DSC file is not used to specify how compiled binary images get placed
+#       into firmware volume images. This section is just a list of modules to compile from
+#       source into UEFI-compliant binaries.
+#       It is the FDF file that contains information on combining binary files into firmware
+#       volume images, whose concept is beyond UEFI and is described in PI specification.
+#       Binary modules do not need to be listed in this section, as they should be
+#       specified in the FDF file. For example: Shell binary (Shell_Full.efi), FAT binary (Fat.efi),
+#       Logo (Logo.bmp), and etc.
+#       There may also be modules listed in this section that are not required in the FDF file,
+#       When a module listed here is excluded from FDF file, then UEFI-compliant binary will be
+#       generated for it, but the binary will not be put into any firmware volume.
+#
+###################################################################################################
+
+[Components.IA32]
+  #
+  # SEC
+  #
+  IntelFsp2Pkg/FspSecCore/FspSecCoreT.inf {
+    <LibraryClasses>
+      FspSecPlatformLib|$(FSP_PACKAGE)/Library/PlatformSecLib/Vtf0PlatformSecTLib.inf
+  }
+
+  IntelFsp2Pkg/FspSecCore/FspSecCoreM.inf {
+    <LibraryClasses>
+      FspSecPlatformLib|$(FSP_PACKAGE)/Library/PlatformSecLib/Vtf0PlatformSecMLib.inf
+  }
+
+  IntelFsp2Pkg/FspSecCore/FspSecCoreS.inf {
+    <LibraryClasses>
+      FspSecPlatformLib|$(FSP_PACKAGE)/Library/PlatformSecLib/Vtf0PlatformSecSLib.inf
+  }
+
+  #
+  # PEI Core
+  #
+  MdeModulePkg/Core/Pei/PeiMain.inf
+
+  #
+  # PCD
+  #
+  MdeModulePkg/Universal/PCD/Pei/Pcd.inf {
+    <LibraryClasses>
+      DebugLib|MdePkg/Library/BaseDebugLibNull/BaseDebugLibNull.inf
+      PcdLib|MdePkg/Library/BasePcdLibNull/BasePcdLibNull.inf
+  }
+
+  #
+  # FSP Binary Components
+  #
+  $(FSP_PACKAGE)/FspHeader/FspHeader.inf
+  $(FSP_PACKAGE)/FspmInit/FspmInit.inf
+  $(FSP_PACKAGE)/FspsInit/FspsInit.inf
+  $(FSP_PACKAGE)/QemuVideo/QemuVideo.inf
+  MdeModulePkg/Core/DxeIplPeim/DxeIpl.inf {
+    <LibraryClasses>
+      DebugAgentLib|MdeModulePkg/Library/DebugAgentLibNull/DebugAgentLibNull.inf
+      ResetSystemLib|MdeModulePkg/Library/BaseResetSystemLibNull/BaseResetSystemLibNull.inf
+  }
+  IntelFsp2Pkg/FspNotifyPhase/FspNotifyPhasePeim.inf
+
+###################################################################################################
+#
+# BuildOptions Section - Define the module specific tool chain flags that should be used as
+#                        the default flags for a module. These flags are appended to any
+#                        standard flags that are defined by the build process. They can be
+#                        applied for any modules or only those modules with the specific
+#                        module style (EDK or EDKII) specified in [Components] section.
+#
+###################################################################################################
+[BuildOptions]
+# Append build options for EDK and EDKII drivers (= is Append, == is Replace)
+  # Enable link-time optimization when building with GCC49
+  *_GCC49_IA32_CC_FLAGS = -flto
+  *_GCC49_IA32_DLINK_FLAGS = -flto
+  *_GCC5_IA32_CC_FLAGS = -fno-pic
+  *_GCC5_IA32_DLINK_FLAGS = -no-pie
+  *_GCC5_IA32_ASLCC_FLAGS = -fno-pic
+  *_GCC5_IA32_ASLDLINK_FLAGS = -no-pie
+  *_XCODE5_IA32_CC_FLAGS = -flto
diff --git a/QemuFspPkg/QemuFspPkg.fdf b/QemuFspPkg/QemuFspPkg.fdf
new file mode 100644
index 0000000000..7ab51f9d1b
--- /dev/null
+++ b/QemuFspPkg/QemuFspPkg.fdf
@@ -0,0 +1,278 @@
+## @file
+# FSP FDF build file for QEMU platform
+#
+# Copyright (c) 2017 - 2018, Intel Corporation. All rights reserved.<BR>
+#
+#    This program and the accompanying materials
+#    are licensed and made available under the terms and conditions of the BSD License
+#    which accompanies this distribution. The full text of the license may be found at
+#    http://opensource.org/licenses/bsd-license.php
+#
+#    THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#    WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+##
+
+[Defines]
+DEFINE FLASH_BASE           = 0xFFFC8000
+DEFINE FLASH_BLOCK_SIZE     = 0x00000100
+
+#
+# Flash Size for Visual Studio and GCC
+#
+DEFINE FLASH_SIZE           = 0x0003A000
+DEFINE FLASH_NUM_BLOCKS     = 0x3A0          #The number of blocks
+
+SET gQemuFspPkgTokenSpaceGuid.PcdFlashFvFspsBase  = 0x00000000
+SET gQemuFspPkgTokenSpaceGuid.PcdFlashFvFspsSize  = 0x00015000
+
+SET gQemuFspPkgTokenSpaceGuid.PcdFlashFvFspmBase  = 0x00015000
+SET gQemuFspPkgTokenSpaceGuid.PcdFlashFvFspmSize  = 0x00022000
+
+SET gQemuFspPkgTokenSpaceGuid.PcdFlashFvFsptBase  = 0x00037000
+SET gQemuFspPkgTokenSpaceGuid.PcdFlashFvFsptSize  = 0x00003000
+
+################################################################################
+#
+# FD Section
+# The [FD] Section is made up of the definition statements and a
+# description of what goes into  the Flash Device Image.  Each FD section
+# defines one flash "device" image.  A flash device image may be one of
+# the following: Removable media bootable image (like a boot floppy
+# image,) an Option ROM image (that would be "flashed" into an add-in
+# card,) a System "Flash"  image (that would be burned into a system's
+# flash) or an Update ("Capsule") image that will be used to update and
+# existing system flash.
+#
+################################################################################
+[FD.QEMUFSP]
+#
+# This FD currently contains all FV regions needed full BROXTON_FSP.fd
+#
+BaseAddress   = $(FLASH_BASE) | gIntelFsp2PkgTokenSpaceGuid.PcdFspAreaBaseAddress
+Size          = $(FLASH_SIZE) | gIntelFsp2PkgTokenSpaceGuid.PcdFspAreaSize
+ErasePolarity = 1
+BlockSize     = $(FLASH_BLOCK_SIZE)
+NumBlocks     = $(FLASH_NUM_BLOCKS)          #The number of blocks for 2Mb FLASH Device.
+
+SET gIntelFsp2PkgTokenSpaceGuid.PcdFspBootFirmwareVolumeBase = $(FLASH_BASE) + (gQemuFspPkgTokenSpaceGuid.PcdFlashFvFspmBase)
+
+#FSP-C
+#gQemuFspPkgTokenSpaceGuid.PcdFlashFvFspCOffset|gQemuFspPkgTokenSpaceGuid.PcdFlashFvFspCSize
+#FV = FSP-C
+
+#FSP-S
+gQemuFspPkgTokenSpaceGuid.PcdFlashFvFspsBase|gQemuFspPkgTokenSpaceGuid.PcdFlashFvFspsSize
+FV = FSP-S
+
+#FSP-M
+gQemuFspPkgTokenSpaceGuid.PcdFlashFvFspmBase|gQemuFspPkgTokenSpaceGuid.PcdFlashFvFspmSize
+FV = FSP-M
+
+#FSP-T
+gQemuFspPkgTokenSpaceGuid.PcdFlashFvFsptBase|gQemuFspPkgTokenSpaceGuid.PcdFlashFvFsptSize
+FV = FSP-T
+
+################################################################################
+#
+# FV Section
+#
+# [FV] section is used to define what components or modules are placed within a flash
+# device file.  This section also defines order the components and modules are positioned
+# within the image.  The [FV] section consists of define statements, set statements and
+# module statements.
+#
+################################################################################
+[FV.FSP-T]
+BlockSize          = $(FLASH_BLOCK_SIZE)
+FvAlignment        = 16
+ERASE_POLARITY     = 1
+MEMORY_MAPPED      = TRUE
+STICKY_WRITE       = TRUE
+LOCK_CAP           = TRUE
+LOCK_STATUS        = TRUE
+WRITE_DISABLED_CAP = TRUE
+WRITE_ENABLED_CAP  = TRUE
+WRITE_STATUS       = TRUE
+WRITE_LOCK_CAP     = TRUE
+WRITE_LOCK_STATUS  = TRUE
+READ_DISABLED_CAP  = TRUE
+READ_ENABLED_CAP   = TRUE
+READ_STATUS        = TRUE
+READ_LOCK_CAP      = TRUE
+READ_LOCK_STATUS   = TRUE
+FvNameGuid         = 52F1AFB6-78A6-448f-8274-F370549AC5D0
+
+#
+# FSP header
+#
+INF  RuleOverride = FSPHEADER   $(FSP_PACKAGE)/FspHeader/FspHeader.inf
+
+#
+# Project specific configuration data files
+#
+!ifndef $(CFG_PREBUILD)
+FILE RAW = $(FSP_T_UPD_FFS_GUID) {
+    SECTION RAW = $(OUTPUT_DIRECTORY)/$(TARGET)_$(TOOL_CHAIN_TAG)/FV/$(FSP_T_UPD_TOOL_GUID).bin
+}
+!endif
+
+INF RuleOverride = RELOC   IntelFsp2Pkg/FspSecCore/FspSecCoreT.inf
+
+[FV.FSP-M]
+BlockSize          = $(FLASH_BLOCK_SIZE)
+FvAlignment        = 16
+ERASE_POLARITY     = 1
+MEMORY_MAPPED      = TRUE
+STICKY_WRITE       = TRUE
+LOCK_CAP           = TRUE
+LOCK_STATUS        = TRUE
+WRITE_DISABLED_CAP = TRUE
+WRITE_ENABLED_CAP  = TRUE
+WRITE_STATUS       = TRUE
+WRITE_LOCK_CAP     = TRUE
+WRITE_LOCK_STATUS  = TRUE
+READ_DISABLED_CAP  = TRUE
+READ_ENABLED_CAP   = TRUE
+READ_STATUS        = TRUE
+READ_LOCK_CAP      = TRUE
+READ_LOCK_STATUS   = TRUE
+FvNameGuid         = F32DB7DF-C5BC-423c-9416-08F1FA26A282
+
+#
+# FSP header
+#
+INF  RuleOverride = FSPHEADER   $(FSP_PACKAGE)/FspHeader/FspHeader.inf
+
+#
+# Project specific configuration data files
+#
+!ifndef $(CFG_PREBUILD)
+FILE RAW = $(FSP_M_UPD_FFS_GUID) {
+    SECTION RAW = $(OUTPUT_DIRECTORY)/$(TARGET)_$(TOOL_CHAIN_TAG)/FV/$(FSP_M_UPD_TOOL_GUID).bin
+}
+!endif
+
+#
+# It is important to keep the proper order for these PEIMs
+# for this implementation
+#
+INF RuleOverride = RELOC   IntelFsp2Pkg/FspSecCore/FspSecCoreM.inf
+
+INF MdeModulePkg/Core/Pei/PeiMain.inf
+INF MdeModulePkg/Universal/PCD/Pei/Pcd.inf
+
+#
+# Project specific PEIMs
+#
+INF $(FSP_PACKAGE)/FspmInit/FspmInit.inf
+
+#
+# Description file
+#
+FILE RAW = D9093578-08EB-44DF-B9D8-D0C1D3D55D96 {
+    SECTION RAW = $(FSP_PACKAGE)/FspDescription/FspDescription.txt
+}
+
+
+[FV.FSP-S]
+BlockSize          = $(FLASH_BLOCK_SIZE)
+FvAlignment        = 16
+ERASE_POLARITY     = 1
+MEMORY_MAPPED      = TRUE
+STICKY_WRITE       = TRUE
+LOCK_CAP           = TRUE
+LOCK_STATUS        = TRUE
+WRITE_DISABLED_CAP = TRUE
+WRITE_ENABLED_CAP  = TRUE
+WRITE_STATUS       = TRUE
+WRITE_LOCK_CAP     = TRUE
+WRITE_LOCK_STATUS  = TRUE
+READ_DISABLED_CAP  = TRUE
+READ_ENABLED_CAP   = TRUE
+READ_STATUS        = TRUE
+READ_LOCK_CAP      = TRUE
+READ_LOCK_STATUS   = TRUE
+FvNameGuid         = 1B5C27FE-F01C-4fbc-AEAE-341B2E992A17
+
+#
+# FSP header
+#
+INF RuleOverride = FSPHEADER   $(FSP_PACKAGE)/FspHeader/FspHeader.inf
+
+#
+# Project specific configuration data files
+#
+!ifndef $(CFG_PREBUILD)
+FILE RAW = $(FSP_S_UPD_FFS_GUID) {
+    SECTION RAW = $(OUTPUT_DIRECTORY)/$(TARGET)_$(TOOL_CHAIN_TAG)/FV/$(FSP_S_UPD_TOOL_GUID).bin
+}
+!endif
+
+#
+# It is important to keep the proper order for these PEIMs
+# for this implementation
+#
+INF RuleOverride = RELOC   IntelFsp2Pkg/FspSecCore/FspSecCoreS.inf
+
+INF MdeModulePkg/Core/DxeIplPeim/DxeIpl.inf
+INF RuleOverride = PE32  $(FSP_PACKAGE)/FspsInit/FspsInit.inf
+INF RuleOverride = PE32  $(FSP_PACKAGE)/QemuVideo/QemuVideo.inf
+INF RuleOverride = PE32    IntelFsp2Pkg/FspNotifyPhase/FspNotifyPhasePeim.inf
+
+
+[Rule.Common.SEC]
+  FILE SEC = $(NAMED_GUID) RELOCS_STRIPPED {
+    TE  TE    Align = 8       $(INF_OUTPUT)/$(MODULE_NAME).efi
+  }
+
+[Rule.Common.SEC.RELOC]
+  FILE SEC = $(NAMED_GUID) {
+    TE  TE    Align = 8       $(INF_OUTPUT)/$(MODULE_NAME).efi
+  }
+
+[Rule.Common.PEI_CORE]
+  FILE PEI_CORE = $(NAMED_GUID)            {
+    TE       TE               $(INF_OUTPUT)/$(MODULE_NAME).efi
+    UI       STRING="$(MODULE_NAME)" Optional
+    VERSION  STRING="$(INF_VERSION)" Optional BUILD_NUM=$(BUILD_NUMBER)
+  }
+
+[Rule.Common.PEIM.NORELOC]
+  FILE PEIM = $(NAMED_GUID) RELOCS_STRIPPED  {
+     PEI_DEPEX PEI_DEPEX Optional        $(INF_OUTPUT)/$(MODULE_NAME).depex
+     TE        TE                        $(INF_OUTPUT)/$(MODULE_NAME).efi
+     UI        STRING="$(MODULE_NAME)" Optional
+     VERSION   STRING="$(INF_VERSION)" Optional BUILD_NUM=$(BUILD_NUMBER)
+  }
+
+[Rule.Common.PEIM]
+  FILE PEIM = $(NAMED_GUID)               {
+     PEI_DEPEX PEI_DEPEX Optional        $(INF_OUTPUT)/$(MODULE_NAME).depex
+     TE        TE                        $(INF_OUTPUT)/$(MODULE_NAME).efi
+     UI        STRING="$(MODULE_NAME)" Optional
+     VERSION   STRING="$(INF_VERSION)" Optional BUILD_NUM=$(BUILD_NUMBER)
+  }
+
+[Rule.Common.PEIM.PE32]
+  FILE PEIM = $(NAMED_GUID)               {
+     PEI_DEPEX PEI_DEPEX Optional        $(INF_OUTPUT)/$(MODULE_NAME).depex
+     COMPRESS {
+        PE32      PE32                   $(INF_OUTPUT)/$(MODULE_NAME).efi
+        UI        STRING="$(MODULE_NAME)" Optional
+        VERSION   STRING="$(INF_VERSION)" Optional BUILD_NUM=$(BUILD_NUMBER)
+     }
+  }
+
+[Rule.Common.PEIM.BINARY]
+  FILE PEIM = $(NAMED_GUID)               {
+     PEI_DEPEX PEI_DEPEX Optional        |.depex
+     PE32      PE32    Align=Auto        |.efi
+     UI        STRING="$(MODULE_NAME)" Optional
+     VERSION   STRING="$(INF_VERSION)" Optional BUILD_NUM=$(BUILD_NUMBER)
+  }
+
+[Rule.Common.USER_DEFINED.FSPHEADER]
+  FILE RAW = $(NAMED_GUID)               {
+     RAW BIN                  |.acpi
+  }
diff --git a/QemuFspPkg/QemuVideo/QemuVideo.c b/QemuFspPkg/QemuVideo/QemuVideo.c
new file mode 100644
index 0000000000..8967e3de88
--- /dev/null
+++ b/QemuFspPkg/QemuVideo/QemuVideo.c
@@ -0,0 +1,780 @@
+/** @file
+  Graphics Output Protocol functions for the QEMU video controller.
+
+  Copyright (c) 2016 - 2018, Intel Corporation. All rights reserved.<BR>
+
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution. The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include <PiPei.h>
+#include <IndustryStandard/Pci30.h>
+#include <Library/PeimEntryPoint.h>
+#include <Library/IoLib.h>
+#include <Library/PciLib.h>
+#include <Library/HobLib.h>
+#include <Library/BaseMemoryLib.h>
+#include <Library/DebugLib.h>
+#include <Library/PeiServicesLib.h>
+#include <Library/PeiServicesTablePointerLib.h>
+#include <Library/PeiServicesLib.h>
+#include <Library/FspCommonLib.h>
+#include <Library/MemoryAllocationLib.h>
+#include <Ppi/Graphics.h>
+#include <Protocol/PciEnumerationComplete.h>
+#include <Guid/GraphicsInfoHob.h>
+#include <IndustryStandard/Bmp.h>
+#include <FspsUpd.h>
+#include "QemuVideo.h"
+
+#define  BPP     4
+
+EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE   *mMode;
+QEMU_VIDEO_PRIVATE_DATA              mPrivate;
+
+QEMU_VIDEO_BOCHS_MODES  mQemuVideoBochsModes[] = {
+  {  640,  480 },
+  {  800,  600 },
+  { 1024,  768 },
+};
+
+/**
+  PEI Graphics PPI structure instance.
+**/
+EFI_PEI_GRAPHICS_PPI mQemuPeiGraphicsPpi = {
+  QemuPeiGraphicsInit,
+  QemuPeiGraphicsGetMode,
+};
+
+/**
+  Ppis to be installed
+**/
+EFI_PEI_PPI_DESCRIPTOR           mPeiGraphicsPpi[] = {
+  {
+    (EFI_PEI_PPI_DESCRIPTOR_PPI | EFI_PEI_PPI_DESCRIPTOR_TERMINATE_LIST),
+    &gEfiPeiGraphicsPpiGuid,
+    &mQemuPeiGraphicsPpi
+  }
+};
+
+EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE  *Mode = NULL;
+
+/**
+  Convert a *.BMP graphics image to a GOP blt buffer. If a NULL Blt buffer
+  is passed in a GopBlt buffer will be allocated by this routine. If a GopBlt
+  buffer is passed in it will be used if it is big enough.
+
+  @param[in]      BmpImage      Pointer to BMP file
+  @param[in]      BmpImageSize  Number of bytes in BmpImage
+  @param[in]      GopBlt        Buffer containing GOP version of BmpImage.
+  @param[in,out]  GopBltSize    Size of GopBlt in bytes.
+  @param[in,out]  PixelHeight   Height of GopBlt/BmpImage in pixels
+  @param[in,out]  PixelWidth    Width of GopBlt/BmpImage in pixels
+
+  @retval EFI_SUCCESS           GopBlt and GopBltSize are returned.
+  @retval EFI_UNSUPPORTED       BmpImage is not a valid *.BMP image
+  @retval EFI_BUFFER_TOO_SMALL  The passed in GopBlt buffer is not big enough.
+                                GopBltSize will contain the required size.
+  @retval EFI_OUT_OF_RESOURCES  No enough buffer to allocate.
+
+**/
+
+EFI_STATUS
+ConvertBmpToGopBlt (
+  IN     VOID      *BmpImage,
+  IN     UINTN     BmpImageSize,
+  IN OUT VOID      **GopBlt,
+  IN OUT UINTN     *GopBltSize,
+  OUT UINTN        *PixelHeight,
+  OUT UINTN        *PixelWidth
+  )
+{
+  EFI_STATUS                    Status = EFI_SUCCESS;
+  UINT8                         *Image;
+  UINT8                         *ImageHeader;
+  BMP_IMAGE_HEADER              *BmpHeader;
+  BMP_COLOR_MAP                 *BmpColorMap;
+  EFI_GRAPHICS_OUTPUT_BLT_PIXEL *BltBuffer;
+  EFI_GRAPHICS_OUTPUT_BLT_PIXEL *Blt;
+  UINT64                        BltBufferSize;
+  UINTN                         Index;
+  UINTN                         Height;
+  UINTN                         Width;
+  UINTN                         ImageIndex;
+  UINT32                        DataSizePerLine;
+  BOOLEAN                       IsAllocated;
+  UINT32                        ColorMapNum;
+  UINTN                         MemPages;
+
+  if (sizeof (BMP_IMAGE_HEADER) > BmpImageSize) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  BmpHeader = (BMP_IMAGE_HEADER *) BmpImage;
+
+  if (BmpHeader->CharB != 'B' || BmpHeader->CharM != 'M') {
+    return EFI_UNSUPPORTED;
+  }
+
+  //
+  // Doesn't support compress.
+  //
+  if (BmpHeader->CompressionType != 0) {
+    return EFI_UNSUPPORTED;
+  }
+
+  //
+  // Only support BITMAPINFOHEADER format.
+  // BITMAPFILEHEADER + BITMAPINFOHEADER = BMP_IMAGE_HEADER
+  //
+  if (BmpHeader->HeaderSize != (sizeof (BMP_IMAGE_HEADER) - OFFSET_OF (BMP_IMAGE_HEADER, HeaderSize))) {
+    return EFI_UNSUPPORTED;
+  }
+
+  //
+  // The data size in each line must be 4 byte alignment.
+  //
+  DataSizePerLine = ((BmpHeader->PixelWidth * BmpHeader->BitPerPixel + 31) >> 3) & (~0x3);
+  BltBufferSize = MultU64x32 (DataSizePerLine, BmpHeader->PixelHeight);
+  if (BltBufferSize > (UINT32) ~0) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  //
+  // Calculate Color Map offset in the image.
+  //
+  Image       = BmpImage;
+  BmpColorMap = (BMP_COLOR_MAP *) (Image + sizeof (BMP_IMAGE_HEADER));
+  if (BmpHeader->ImageOffset < sizeof (BMP_IMAGE_HEADER)) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if (BmpHeader->ImageOffset > sizeof (BMP_IMAGE_HEADER)) {
+    switch (BmpHeader->BitPerPixel) {
+      case 1:
+        ColorMapNum = 2;
+        break;
+      case 4:
+        ColorMapNum = 16;
+        break;
+      case 8:
+        ColorMapNum = 256;
+        break;
+      default:
+        ColorMapNum = 0;
+        break;
+    }
+    if (BmpHeader->ImageOffset - sizeof (BMP_IMAGE_HEADER) != sizeof (BMP_COLOR_MAP) * ColorMapNum) {
+      return EFI_INVALID_PARAMETER;
+    }
+  }
+
+  //
+  // Calculate graphics image data address in the image
+  //
+  Image         = ((UINT8 *) BmpImage) + BmpHeader->ImageOffset;
+  ImageHeader   = Image;
+
+  //
+  // Calculate the BltBuffer needed size.
+  //
+  BltBufferSize = MultU64x32 ((UINT64) BmpHeader->PixelWidth, BmpHeader->PixelHeight);
+
+  //
+  // Ensure the BltBufferSize * sizeof (EFI_GOP_BLT_PIXEL) doesn't overflow
+  //
+  if (BltBufferSize > DivU64x32 ((UINTN) ~0, sizeof (EFI_GRAPHICS_OUTPUT_BLT_PIXEL))) {
+    return EFI_UNSUPPORTED;
+  }
+  BltBufferSize = MultU64x32 (BltBufferSize, sizeof (EFI_GRAPHICS_OUTPUT_BLT_PIXEL));
+
+  IsAllocated   = FALSE;
+  if (*GopBlt == NULL) {
+    //
+    // GopBlt is not allocated by caller.
+    //
+    *GopBltSize = (UINTN) BltBufferSize;
+    MemPages =  (*GopBltSize/ EFI_PAGE_SIZE) + 1;
+    Status = PeiServicesAllocatePages (
+               EfiBootServicesData,
+               MemPages,
+               ((EFI_PHYSICAL_ADDRESS*) GopBlt)
+               );
+    if (EFI_ERROR (Status)) {
+      return EFI_OUT_OF_RESOURCES;
+    }
+    DEBUG ((DEBUG_INFO, "GopBlt = 0x%X \n", *GopBlt));
+    IsAllocated = TRUE;
+    if (*GopBlt == NULL) {
+      return EFI_OUT_OF_RESOURCES;
+    }
+  } else {
+    //
+    // GopBlt has been allocated by caller.
+    //
+    if (*GopBltSize < (UINTN) BltBufferSize) {
+      *GopBltSize = (UINTN) BltBufferSize;
+      return EFI_BUFFER_TOO_SMALL;
+    }
+  }
+
+  *PixelWidth   = BmpHeader->PixelWidth;
+  *PixelHeight  = BmpHeader->PixelHeight;
+
+  //
+  // Convert image from BMP to Blt buffer format
+  //
+  BltBuffer = *GopBlt;
+  for (Height = 0; Height < BmpHeader->PixelHeight; Height++) {
+    Blt = &BltBuffer[ (BmpHeader->PixelHeight - Height - 1) * BmpHeader->PixelWidth];
+    for (Width = 0; Width < BmpHeader->PixelWidth; Width++, Image++, Blt++) {
+      switch (BmpHeader->BitPerPixel) {
+        case 1:
+          //
+          // Convert 1-bit (2 colors) BMP to 24-bit color
+          //
+          for (Index = 0; Index < 8 && Width < BmpHeader->PixelWidth; Index++) {
+            Blt->Red    = BmpColorMap[ ((*Image) >> (7 - Index)) & 0x1].Red;
+            Blt->Green  = BmpColorMap[ ((*Image) >> (7 - Index)) & 0x1].Green;
+            Blt->Blue   = BmpColorMap[ ((*Image) >> (7 - Index)) & 0x1].Blue;
+            Blt++;
+            Width++;
+          }
+
+          Blt--;
+          Width--;
+          break;
+
+        case 4:
+          //
+          // Convert 4-bit (16 colors) BMP Palette to 24-bit color
+          //
+          Index       = (*Image) >> 4;
+          Blt->Red    = BmpColorMap[Index].Red;
+          Blt->Green  = BmpColorMap[Index].Green;
+          Blt->Blue   = BmpColorMap[Index].Blue;
+          if (Width < (BmpHeader->PixelWidth - 1)) {
+            Blt++;
+            Width++;
+            Index       = (*Image) & 0x0f;
+            Blt->Red    = BmpColorMap[Index].Red;
+            Blt->Green  = BmpColorMap[Index].Green;
+            Blt->Blue   = BmpColorMap[Index].Blue;
+          }
+          break;
+
+        case 8:
+          //
+          // Convert 8-bit (256 colors) BMP Palette to 24-bit color
+          //
+          Blt->Red    = BmpColorMap[*Image].Red;
+          Blt->Green  = BmpColorMap[*Image].Green;
+          Blt->Blue   = BmpColorMap[*Image].Blue;
+          break;
+
+        case 24:
+          //
+          // It is 24-bit BMP.
+          //
+          Blt->Blue   = *Image++;
+          Blt->Green  = *Image++;
+          Blt->Red    = *Image;
+          break;
+
+        default:
+          //
+          // Other bit format BMP is not supported.
+          //
+          if (IsAllocated) {
+            FreePool (*GopBlt);
+            *GopBlt = NULL;
+          }
+          return EFI_UNSUPPORTED;
+          break;
+      };
+
+    }
+    ImageIndex = (UINTN) (Image - ImageHeader);
+    if ((ImageIndex % 4) != 0) {
+      //
+      // Bmp Image starts each row on a 32-bit boundary!
+      //
+      Image = Image + (4 - (ImageIndex % 4));
+    }
+  }
+
+  return EFI_SUCCESS;
+}
+
+/**
+  FillFrameBufferAndShowLogo: Fill frame buffer with the image
+
+  @param[in] GtConfig                    GRAPHICS_CONFIG to access the GtConfig related information
+             GtConfig.GraphicsConfigPtr  Address of the Graphics Configuration Table
+
+  @retval    EFI_STATUS
+**/
+
+EFI_STATUS
+FillFrameBufferAndShowLogo(
+  IN  GRAPHICS_CONFIG  *GtConfig
+)
+{
+  VOID*                         Buffer;
+  UINT32                        Size;
+  EFI_GRAPHICS_OUTPUT_BLT_PIXEL *Blt = NULL;
+  UINTN                         BltSize;
+  UINTN                         Height;
+  UINTN                         Width;
+  EFI_STATUS                    Status = EFI_SUCCESS;
+  UINTN                         LogoDestX;
+  UINTN                         LogoDestY;
+  UINTN                         SrcY,DstY;
+  UINT8                         *SrcAddress;
+  UINT8                         *DstAddress;
+  UINT32                        BytesPerScanLine;
+
+  DEBUG ((DEBUG_INFO, "FillFrameBufferAndShowLogo: Start \n"));
+
+  if (Mode == NULL) {
+    DEBUG ((DEBUG_INFO, "Returning from FillFrameBufferAndShowLogo() due to invalid mode\n"));
+    return EFI_UNSUPPORTED;
+  }
+
+  ///
+  /// Get the Logo pointer and Size .
+  ///
+  Buffer = GtConfig->LogoPtr;
+  Size =   GtConfig->LogoSize;
+
+  if (Buffer == 0) {
+    DEBUG ((DEBUG_ERROR, "No Logo information. Returning from FillFrameBufferAndShowLogo()\n"));
+    return EFI_UNSUPPORTED;
+  }
+  ///
+  /// Convert Bmp Image to GopBlt
+  ///
+  Status = ConvertBmpToGopBlt (
+             Buffer,
+             (UINTN) Size,
+             (VOID **) &Blt,
+             &BltSize,
+             &Height,
+             &Width
+             );
+  ASSERT_EFI_ERROR (Status);
+
+  //
+  // if Convert Bmp to blt successful fill frame buffer with the image
+  //
+  if (!EFI_ERROR (Status)) {
+    //
+    // if Convert Bmp to blt successful Center the logo and fill frame buffer.
+    //
+    LogoDestX = (Mode->Info->HorizontalResolution - Width) /2;
+    LogoDestY = (Mode->Info->VerticalResolution - Height) /2;
+    BytesPerScanLine = Mode->Info->PixelsPerScanLine*sizeof (EFI_GRAPHICS_OUTPUT_BLT_PIXEL);
+    //
+    // Fill framebuffer with the logo line by line
+    //
+    for (SrcY = 0, DstY = LogoDestY; DstY < (LogoDestY + Height); SrcY++, DstY++) {
+      DstAddress = (UINT8 *) (UINTN) (Mode->FrameBufferBase + DstY * BytesPerScanLine + LogoDestX * sizeof (EFI_GRAPHICS_OUTPUT_BLT_PIXEL));
+      SrcAddress = (UINT8 *) ((UINT8 *) Blt + (SrcY * Width * sizeof (EFI_GRAPHICS_OUTPUT_BLT_PIXEL)));
+      CopyMem (DstAddress, SrcAddress, Width * sizeof (EFI_GRAPHICS_OUTPUT_BLT_PIXEL));
+    }
+  }
+  FreePool (Blt);
+
+  DEBUG ((DEBUG_INFO, "FillFrameBufferAndShowLogo: END \n"));
+
+  return Status;
+}
+
+/**
+  CallPpiAndFillFrameBuffer: Call GraphicsInitPeim PeiGraphicsPpi to initalize display and get Mode info.
+  Publish GraphicsInfoHob and call FillFrameBufferAndShowLogo
+
+  @param[in]  GtConfig            GRAPHICS_CONFIG to access the GtConfig related information
+              GtConfig.LogoPtr    Address of Logo to be displayed
+              GtConfig.LogoSize   Logo Size
+
+  @retval    EFI_STATUS
+**/
+EFI_STATUS
+EFIAPI
+CallPpiAndFillFrameBuffer (
+  IN   GRAPHICS_CONFIG             *GtConfig
+  )
+{
+  EFI_STATUS                  Status = EFI_SUCCESS;
+
+  EFI_PEI_GRAPHICS_INFO_HOB   *PlatformGraphicsOutput;
+
+  DEBUG ((DEBUG_INFO, "CallPpiAndFillFrameBuffer: Begin \n"));
+
+
+  Mode       = AllocateZeroPool (sizeof (EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE));
+  if(Mode == NULL){
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  Mode->Info = AllocateZeroPool (sizeof (EFI_GRAPHICS_OUTPUT_MODE_INFORMATION));
+  if(Mode->Info == NULL){
+    return EFI_OUT_OF_RESOURCES;
+  }
+  ///
+  /// Call PeiGraphicsPpi.GraphicsPpiGetMode to get display resolution
+  ///
+  DEBUG ((DEBUG_INFO, "GraphicsPpiGetMode Start\n"));
+  Status = QemuPeiGraphicsGetMode (Mode);
+  if (EFI_ERROR (Status)) {
+    DEBUG ((DEBUG_ERROR, "GraphicsPpiGetMode failed. \n"));
+    return Status;
+  }
+
+  ///
+  /// Print Mode information recived from GraphicsPeim
+  ///
+  DEBUG ((DEBUG_INFO, "MaxMode:0x%x \n", Mode->MaxMode));
+  DEBUG ((DEBUG_INFO, "Mode:0x%x \n", Mode->Mode));
+  DEBUG ((DEBUG_INFO, "SizeOfInfo:0x%x \n", Mode->SizeOfInfo));
+  DEBUG ((DEBUG_INFO, "FrameBufferBase:0x%x \n", Mode->FrameBufferBase));
+  DEBUG ((DEBUG_INFO, "FrameBufferSize:0x%x \n", Mode->FrameBufferSize));
+  DEBUG ((DEBUG_INFO, "Version:0x%x \n", Mode->Info->Version));
+  DEBUG ((DEBUG_INFO, "HorizontalResolution:0x%x \n", Mode->Info->HorizontalResolution));
+  DEBUG ((DEBUG_INFO, "VerticalResolution:0x%x \n", Mode->Info->VerticalResolution));
+  DEBUG ((DEBUG_INFO, "PixelFormat:0x%x \n", Mode->Info->PixelFormat));
+  DEBUG ((DEBUG_INFO, "PixelsPerScanLine:0x%x \n", Mode->Info->PixelsPerScanLine));
+
+  ///
+  /// Publish GraphicsInfoHob to be used by platform code
+  ///
+  PlatformGraphicsOutput = BuildGuidHob (&gEfiGraphicsInfoHobGuid, sizeof (EFI_PEI_GRAPHICS_INFO_HOB));
+
+  if (PlatformGraphicsOutput == NULL) {
+    DEBUG ((DEBUG_ERROR, "Failed to build GraphicsInfoHob. \n"));
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  PlatformGraphicsOutput->GraphicsMode.Version              = Mode->Info->Version;
+  PlatformGraphicsOutput->GraphicsMode.HorizontalResolution = Mode->Info->HorizontalResolution;
+  PlatformGraphicsOutput->GraphicsMode.VerticalResolution   = Mode->Info->VerticalResolution;
+  PlatformGraphicsOutput->GraphicsMode.PixelFormat          = Mode->Info->PixelFormat;
+  PlatformGraphicsOutput->GraphicsMode.PixelInformation     = Mode->Info->PixelInformation;
+  PlatformGraphicsOutput->GraphicsMode.PixelsPerScanLine    = Mode->Info->PixelsPerScanLine;
+  PlatformGraphicsOutput->FrameBufferBase                   = Mode->FrameBufferBase;
+  PlatformGraphicsOutput->FrameBufferSize                   = Mode->FrameBufferSize;
+
+  ///
+  /// Display Logo if user provides valid Bmp image
+  ///
+  if (GtConfig->LogoPtr != 0) {
+    DEBUG ((DEBUG_INFO, "FillFrameBufferAndShowLogo Start\n"));
+    Status = FillFrameBufferAndShowLogo ( GtConfig);
+  }
+
+  DEBUG ((DEBUG_INFO, "CallPpiAndFillFrameBuffer: End \n"));
+
+  return Status;
+}
+
+
+/**
+  This fucntion is the Entry point of GFX PEIM Module
+
+  @param[in] FileHandle     EFI File handle passed by BIOS.
+  @param[in] PeiServices    PEI services pointer passed by reference by BIOS.
+
+  @retval EFI_SUCCESS       If the PPI is installed correctly.
+  @retval EFI_DEVICE_ERROR  If the PPI installation fails.
+**/
+EFI_STATUS
+EFIAPI
+PeiGraphicsEntryPoint (
+  IN EFI_PEI_FILE_HANDLE     FileHandle,
+  IN CONST EFI_PEI_SERVICES  **PeiServices
+  )
+{
+  EFI_STATUS     Status;
+  FSPS_UPD      *FspsUpd;
+  GRAPHICS_DATA *GfxPtr;
+  UINT32         Idx;
+  BOOLEAN        Found;
+  UINT32         ResX;
+  UINT32         ResY;
+
+  FspsUpd = (FSPS_UPD *)GetFspSiliconInitUpdDataPointer();
+  GfxPtr  = (GRAPHICS_DATA *)FspsUpd->FspsConfig.GraphicsConfigPtr;
+
+  if (!(GfxPtr && (GfxPtr->Signature == GRAPHICS_DATA_SIG))) {
+    DEBUG ((DEBUG_INFO, "NO valid graphics config data found!\n"));
+    return EFI_SUCCESS;
+  }
+
+  Found = FALSE;
+  for (Idx = 0; Idx < sizeof(mQemuVideoBochsModes) / sizeof(mQemuVideoBochsModes[0]); Idx++) {
+    if ((mQemuVideoBochsModes[Idx].ResX == GfxPtr->ResX) && \
+        (mQemuVideoBochsModes[Idx].ResY == GfxPtr->ResY)) {
+      Found = TRUE;
+      break;
+    }
+  }
+  if (!Found) {
+    Idx = 1;
+  }
+
+  ResX = mQemuVideoBochsModes[Idx].ResX;
+  ResY = mQemuVideoBochsModes[Idx].ResY;
+
+  mMode = AllocateZeroPool (sizeof (EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE));
+  mMode->Info->Version              = 0;
+  mMode->Info->PixelFormat          = PixelBlueGreenRedReserved8BitPerColor;
+  mMode->SizeOfInfo                 = sizeof (EFI_GRAPHICS_OUTPUT_MODE_INFORMATION);
+  mMode->FrameBufferBase            = 0xF0000000;
+  mMode->Info->HorizontalResolution = ResX;
+  mMode->Info->VerticalResolution   = ResY;
+  mMode->Info->PixelsPerScanLine    = (((ResX * BPP) + 63) & 0xFFFFFFC0) / BPP;
+  mMode->FrameBufferSize            = mMode->Info->PixelsPerScanLine * ResY * BPP;
+  mMode->MaxMode                    = 1;
+  mMode->Mode                       = 0;
+
+  Status = PeiServicesInstallPpi (&mPeiGraphicsPpi[0]);
+  if (EFI_ERROR (Status)) {
+    Status = EFI_DEVICE_ERROR;
+    DEBUG ((DEBUG_ERROR, "Failed to install Pei Graphics PPI\n"));
+    ASSERT (FALSE);
+  }
+
+  return Status;
+}
+
+/**
+  This function returns the current graphics mode information.
+
+  @param[out] Mode    Pointer to graphics mode information
+
+  @retval EFI_SUCCESS     Mode information is returned.
+  @retval EFI_NOT_READY   Mode information is not returned.
+**/
+EFI_STATUS
+GetCurrentMode (
+  OUT EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE *GfxMode
+  )
+{
+  if (mMode == NULL) {
+    DEBUG ((DEBUG_ERROR,"[ERROR]:[GetCurrentMode()]:[No current mode created]\n"));
+    return EFI_NOT_READY;
+  }
+
+  GfxMode->Info->Version              = mMode->Info->Version;
+  GfxMode->Info->PixelFormat          = mMode->Info->PixelFormat;
+  GfxMode->SizeOfInfo                 = mMode->SizeOfInfo;
+  GfxMode->FrameBufferBase            = mMode->FrameBufferBase;
+  GfxMode->Info->HorizontalResolution = mMode->Info->HorizontalResolution;
+  GfxMode->Info->VerticalResolution   = mMode->Info->VerticalResolution;
+  GfxMode->Info->PixelsPerScanLine    = mMode->Info->PixelsPerScanLine;
+  GfxMode->FrameBufferSize            = mMode->FrameBufferSize;
+  GfxMode->MaxMode                    = mMode->MaxMode;
+  GfxMode->Mode                       = mMode->Mode;
+
+  return EFI_SUCCESS;
+}
+
+/**
+  Display I/O port write
+
+  @param[in] Private              Private data structure pointer.
+  @param[in] Reg                  Register offset.
+  @param[in] Data                 Register data.
+
+**/
+VOID
+BochsWrite (
+  QEMU_VIDEO_PRIVATE_DATA  *Private,
+  UINT16                   Reg,
+  UINT16                   Data
+  )
+{
+  if (Private->Bar2 == 0) {
+    IoWrite16 (VBE_DISPI_IOPORT_INDEX, Reg);
+    IoWrite16 (VBE_DISPI_IOPORT_DATA,  Data);
+  } else {
+    MmioWrite16  (Private->Bar2 + 0x500 + (Reg << 1), Data);
+  }
+}
+
+/**
+  Display I/O port read
+
+  @param[in] Private              Private data structure pointer.
+  @param[in] Reg                  Register offset.
+
+  @retval                         Register data.
+**/
+UINT16
+BochsRead (
+  QEMU_VIDEO_PRIVATE_DATA  *Private,
+  UINT16                   Reg
+  )
+{
+  if (Private->Bar2 == 0) {
+    IoWrite16 (VBE_DISPI_IOPORT_INDEX, Reg);
+    return IoRead16 (VBE_DISPI_IOPORT_DATA);
+  } else {
+    return MmioRead16  (Private->Bar2 + 0x500 + (Reg << 1));
+  }
+}
+
+VOID
+VgaOutb (
+  QEMU_VIDEO_PRIVATE_DATA  *Private,
+  UINTN                    Reg,
+  UINT8                    Data
+  )
+{
+  if (Private->Bar2 == 0) {
+    IoWrite8 (Reg, Data);
+  } else {
+    MmioWrite8  (Private->Bar2 + 0x400 - 0x3c0 + Reg, Data);
+  }
+}
+
+/**
+  Qemu GFX mode initialization
+
+  @param[in] Width      Resolution width.
+  @param[in] Height     Resolution height.
+  @param[in] Bpp        Bytes per pixel.
+  @param[in] PciBase    PCI resource base to use.
+
+**/
+VOID
+BochsInitMode (
+  IN  UINT16  Width,
+  IN  UINT16  Height,
+  IN  UINT8   Bpp,
+  IN  UINT32  PciBase
+)
+{
+  QEMU_VIDEO_PRIVATE_DATA  *Private;
+  UINT32  Address;
+  UINT32  Data;
+  UINT8   Dev;
+
+  Dev = 1;
+  Address = PCI_LIB_ADDRESS (0, Dev, 0, PCI_VENDOR_ID_OFFSET);
+  if ((PciRead32(Address) != QEMU_VGA_VID_DID) && (PciRead32(Address) != QEMU_VGA_VID_DID2)) {
+    Dev = 0x0f;
+    Address = PCI_LIB_ADDRESS (0, Dev, 0, PCI_VENDOR_ID_OFFSET);
+    if ((PciRead32(Address) != QEMU_VGA_VID_DID) && (PciRead32(Address) != QEMU_VGA_VID_DID2)) {
+      DEBUG ((DEBUG_ERROR, "Not supported GFX device!\n"));
+      return;
+    }
+  }
+
+  Private = &mPrivate;
+  Address = PCI_LIB_ADDRESS (0, Dev, 0, PCI_BASE_ADDRESSREG_OFFSET + 0 * 4);
+  Data    = PciRead32(Address) & ~0xF;
+  if (Data == 0) {
+    PciWrite32 (Address, PciBase);
+    PciWrite32 (Address + 2 * 4, PciBase + 0x08000000);
+    Data = PciBase;
+  }
+  mMode->FrameBufferBase = Data;
+
+  Address = PCI_LIB_ADDRESS (0, Dev, 0, PCI_BASE_ADDRESSREG_OFFSET + 2 * 4);
+  mPrivate.Bar2 = PciRead32(Address) & ~0xF;
+
+  Address = PCI_LIB_ADDRESS (0, Dev, 0, PCI_COMMAND_OFFSET);
+  PciWrite8(Address, EFI_PCI_COMMAND_BUS_MASTER | EFI_PCI_COMMAND_MEMORY_SPACE | EFI_PCI_COMMAND_IO_SPACE);
+  BochsWrite (Private, VBE_DISPI_INDEX_ENABLE,      0);
+  BochsWrite (Private, VBE_DISPI_INDEX_BANK,        0);
+  BochsWrite (Private, VBE_DISPI_INDEX_X_OFFSET,    0);
+  BochsWrite (Private, VBE_DISPI_INDEX_Y_OFFSET,    0);
+  BochsWrite (Private, VBE_DISPI_INDEX_BPP,         Bpp * 8);
+  BochsWrite (Private, VBE_DISPI_INDEX_XRES,        Width);
+  BochsWrite (Private, VBE_DISPI_INDEX_VIRT_WIDTH,  Width);
+  BochsWrite (Private, VBE_DISPI_INDEX_YRES,        Height);
+  BochsWrite (Private, VBE_DISPI_INDEX_VIRT_HEIGHT, Height);
+  BochsWrite (Private, VBE_DISPI_INDEX_ENABLE,      VBE_DISPI_ENABLED | VBE_DISPI_LFB_ENABLED);
+
+  VgaOutb    (Private, ATT_ADDRESS_REGISTER,     0x20);
+}
+
+/**
+  This function performs the PEI module initialization.
+
+  @param[in]  GraphicsPolicyPtr   Pointer to the graphics policy structure.
+
+  @retval   EFI_SUCCESS       If initialization is successful.
+  @retval   EFI_DEVICE_ERROR  If initialization fails.
+**/
+EFI_STATUS
+EFIAPI
+QemuPeiGraphicsInit (
+  IN  VOID  *GraphicsPolicyPtr
+  )
+{
+  EFI_STATUS                   Status;
+  GRAPHICS_CONFIG              GfxCfg;
+  FSPS_UPD                    *FspsUpd;
+  UINT32                       ResX;
+  UINT32                       ResY;
+
+  DEBUG ((DEBUG_INFO, "[INFO]:[QemuPeiGraphicsInit]: \n"));
+
+  ResX = mMode->Info->HorizontalResolution;
+  ResY = mMode->Info->VerticalResolution;
+
+  FspsUpd = (FSPS_UPD *)GetFspSiliconInitUpdDataPointer();
+  DEBUG ((DEBUG_INFO, "Initialize GFX mode to %dx%dx%d\n", ResX, ResY, BPP));
+
+  BochsInitMode ((UINT16)ResX, (UINT16)ResY, BPP, FspsUpd->FspsConfig.PciTempResourceBase);
+
+  GfxCfg.LogoPtr           = (VOID *)FspsUpd->FspsConfig.LogoPtr;
+  GfxCfg.LogoSize          = FspsUpd->FspsConfig.LogoSize;
+  GfxCfg.GraphicsConfigPtr = (VOID *)FspsUpd->FspsConfig.GraphicsConfigPtr;
+  Status = CallPpiAndFillFrameBuffer (&GfxCfg);
+
+  return Status;
+}
+
+/**
+  This function returns the PEI graphics mode information.
+
+  @param[out]  Mode   Pointer to graphics mode structure.
+
+  @retval EFI_INVALID_PARAMETER   If Mode is NULL.
+  @retval EFI_NOT_READY           If internal function call to ::GetCurrentMode() fails.
+  @retval EFI_SUCCESS             If the mode information is returned in input argument.
+**/
+EFI_STATUS
+EFIAPI
+QemuPeiGraphicsGetMode (
+  OUT EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE *GfxMode
+  )
+{
+  EFI_STATUS Status;
+
+  if (GfxMode == NULL) {
+    DEBUG ((DEBUG_ERROR,"[ERROR]:[IntelPeiGraphicsGetMode()]:[Error creating Mode information]\n"));
+    return EFI_INVALID_PARAMETER;
+  }
+
+  Status = GetCurrentMode (GfxMode);
+  if (EFI_ERROR(Status)) {
+    return Status;
+  }
+
+  DEBUG ((DEBUG_INFO,"[INFO]:[IntelPeiGraphicsGetMode()]:[Current Mode HRes = %d]\n", GfxMode->Info->HorizontalResolution));
+  DEBUG ((DEBUG_INFO,"[INFO]:[IntelPeiGraphicsGetMode()]:[Current Mode VRes = %d]\n", GfxMode->Info->VerticalResolution));
+
+  return EFI_SUCCESS;
+}
+
diff --git a/QemuFspPkg/QemuVideo/QemuVideo.h b/QemuFspPkg/QemuVideo/QemuVideo.h
new file mode 100644
index 0000000000..52792d7949
--- /dev/null
+++ b/QemuFspPkg/QemuVideo/QemuVideo.h
@@ -0,0 +1,116 @@
+/** @file
+  QEMU video controller register definitions.
+
+  Copyright (c) 2016 - 2018, Intel Corporation. All rights reserved.<BR>
+
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution. The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#ifndef _QEMU_VIDEO_H_
+#define _QEMU_VIDEO_H_
+
+#define QEMU_VGA_VID_DID                 0x11111234
+#define QEMU_VGA_VID_DID2                0x11114321
+
+#define VBE_DISPI_IOPORT_INDEX           0x01CE
+#define VBE_DISPI_IOPORT_DATA            0x01D0
+
+#define ATT_ADDRESS_REGISTER             0x3C0
+
+#define VBE_DISPI_INDEX_ID               0x0
+#define VBE_DISPI_INDEX_XRES             0x1
+#define VBE_DISPI_INDEX_YRES             0x2
+#define VBE_DISPI_INDEX_BPP              0x3
+#define VBE_DISPI_INDEX_ENABLE           0x4
+#define VBE_DISPI_INDEX_BANK             0x5
+#define VBE_DISPI_INDEX_VIRT_WIDTH       0x6
+#define VBE_DISPI_INDEX_VIRT_HEIGHT      0x7
+#define VBE_DISPI_INDEX_X_OFFSET         0x8
+#define VBE_DISPI_INDEX_Y_OFFSET         0x9
+#define VBE_DISPI_INDEX_VIDEO_MEMORY_64K 0xa
+
+#define VBE_DISPI_DISABLED               0x00
+#define VBE_DISPI_ENABLED                0x01
+#define VBE_DISPI_GETCAPS                0x02
+#define VBE_DISPI_8BIT_DAC               0x20
+#define VBE_DISPI_LFB_ENABLED            0x40
+#define VBE_DISPI_NOCLEARMEM             0x80
+
+#define GRAPHICS_DATA_SIG    SIGNATURE_32 ('Q', 'G', 'F', 'X')
+
+typedef struct {
+  VOID*      LogoPtr;
+  UINT32     LogoSize;
+  VOID*      GraphicsConfigPtr;
+} GRAPHICS_CONFIG;
+
+typedef struct {
+  UINT32     Signature;
+  UINT32     ResX;
+  UINT32     ResY;
+} GRAPHICS_DATA;
+
+typedef struct {
+  UINT64                                 Signature;
+  UINT32                                 Bar2;
+} QEMU_VIDEO_PRIVATE_DATA;
+
+typedef struct {
+  UINT32    ResX;
+  UINT32    ResY;
+} QEMU_VIDEO_BOCHS_MODES;
+
+/**
+  Qemu GFX callback initialization after PCI enumeration
+
+  @param[in] PeiServices          General purpose services available to every PEIM.
+  @param[in] NotifyDescriptor     The notification structure this PEIM registered on install.
+  @param[in] Ppi                  The memory discovered PPI.  Not used.
+
+  @retval EFI_SUCCESS             The function completed successfully.
+**/
+EFI_STATUS
+EFIAPI
+QemuPostPciEnumerationCallback (
+  IN  EFI_PEI_SERVICES            **PeiServices,
+  IN  EFI_PEI_NOTIFY_DESCRIPTOR   *NotifyDescriptor,
+  IN  VOID                        *Ppi
+  );
+
+/**
+  This function performs the PEI module initialization.
+
+  @param[in]  GraphicsPolicyPtr   Pointer to the graphics policy structure.
+
+  @retval   EFI_SUCCESS       If initialization is successful.
+  @retval   EFI_DEVICE_ERROR  If initialization fails.
+**/
+EFI_STATUS
+EFIAPI
+QemuPeiGraphicsInit (
+  IN  VOID  *GraphicsPolicyPtr
+  );
+
+/**
+  This function returns the PEI graphics mode information.
+
+  @param[out]  Mode   Pointer to graphics mode structure.
+
+  @retval EFI_INVALID_PARAMETER   If Mode is NULL.
+  @retval EFI_NOT_READY           If internal function call to ::GetCurrentMode() fails.
+  @retval EFI_SUCCESS             If the mode information is returned in input argument.
+**/
+EFI_STATUS
+EFIAPI
+QemuPeiGraphicsGetMode (
+  OUT EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE *Mode
+  );
+
+#endif
diff --git a/QemuFspPkg/QemuVideo/QemuVideo.inf b/QemuFspPkg/QemuVideo/QemuVideo.inf
new file mode 100644
index 0000000000..4c6bc6a0f1
--- /dev/null
+++ b/QemuFspPkg/QemuVideo/QemuVideo.inf
@@ -0,0 +1,56 @@
+## @file
+#  This driver is a sample implementation of the Graphics Output Protocol for
+#  the QEMU (Cirrus Logic 5446) video controller.
+#
+#  Copyright (c) 2016 - 2018, Intel Corporation. All rights reserved.<BR>
+#
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution. The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php
+#
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = QemuVideo
+  FILE_GUID                      = BA37F2C5-B0F3-4a95-B55F-F25F4F6F8452
+  MODULE_TYPE                    = PEIM
+  VERSION_STRING                 = 1.0
+  ENTRY_POINT                    = PeiGraphicsEntryPoint
+
+[Sources]
+  QemuVideo.h
+  QemuVideo.c
+
+[Packages]
+  MdePkg/MdePkg.dec
+  MdeModulePkg/MdeModulePkg.dec
+  IntelFsp2Pkg/IntelFsp2Pkg.dec
+  QemuFspPkg/QemuFspPkg.dec
+
+[LibraryClasses]
+  IoLib
+  DebugLib
+  MemoryAllocationLib
+  PeimEntryPoint
+  PeiServicesLib
+  PeiServicesTablePointerLib
+  PciLib
+  FspCommonLib
+
+[Guids]
+  gEfiGraphicsInfoHobGuid
+
+[Ppis]
+  gEfiPeiGraphicsPpiGuid
+
+[Protocols]
+  gEfiPciEnumerationCompleteProtocolGuid
+
+[Depex]
+  TRUE
+
-- 
2.30.2.windows.1

